<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Understanding dap</title>
	<link href="styles.css" rel="stylesheet" type="text/css"/>	
</head>
<body>

<h1>Understanding dap</h1>
<p>All you need to use dap in your document is a reference to dap runtime script: <code>&lt;script src="https://dap.js.org/0.4.js"&gt;&lt;/script&gt;</code>. You can start your dap experiments with an .html document like this:</p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;My dap playground&lt;/title&gt;
  <b>&lt;script src="https://dap.js.org/0.4.js"&gt;&lt;/script&gt;</b>
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h2&gt;Welcome to dap&lt;/h2&gt;
  &lt;script&gt;
  
   // My dap code here
   
   .RENDER() // this method renders the dap template
   
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Save it on your Desktop (or anywhere else), then open in a web browser. Now you can simply copy-and-paste examples into this file, and refresh browser to see the examples working. Or, you can play with the code right here, all code samples are editable. Results of each code sample are shown under.</p>


<h2>Rules and contexts</h2>
<p>Elements rendered into DOM are generated from <em>dap-templates</em>. Every template defines element's a <em>signature</em> and <em>rules</em> for generated element. Signature designates the element's generic properties: tag, css class, other attributes. Rules define the element's behavior on different phases of its life cycle:</p>
<ul>
	<li><em>d-rule</em> is executed on "down" phase, when the document is populated, from root <i>down</i> to child elements</li>
	<li><em>a-rule</em> is accumulation rule, similar to d-rule, but appends changes to the existing element instead of building it anew</li>
	<li><em>u-rule</em> is executed on "up" phase, when an event bubbles through the element <i>up</i> to the root</li>
	<li><em>e-rule</em> is a variant of u-rule, that not only handles events, but generates them, too</li>
	<li><em>ui-rule</em> is a convenience variant of e-rule dealing with the element's default UI event</li>
</ul>
<p>Every generated element in a dap document is bound to two local contexts: <em>status context</em> and <em>data context</em>. Element's dap rules are executed within these contexts. Constants defined in a dictionary are visible to all elements.</p>

<h3>Literals and constants</h3>
<p>Literal values in dap rules are prefixed with a <code>`</code> (backtick) which can be found on your keyboard somewhere around Esc key. Literal values are not very welcome in dap rules and are usually used for numbers or other short codes. They cannot contain spaces, because spaces are delimeters between tokens within a rule. Textual content, as well as constant values of any other kind should be defined in the <code>.DICT</code> section (the dictionary) and referred to as constants, <code>good</code> in the example below. Keeping all constants grouped in one place helps make the code cleaner and maintainance easier. Dap is rather encouraging to that coding style.</p>
<pre lang="dap">
'B'.d("! good `literals_in_rules_are_not_good_for_long_texts")
.DICT({ // this is the dictionary
	good:"The right place for text and other constants is the dictionary, "
})
</pre>
<p>Exclamation sign <code>!</code> in the beginning of the rule is a "print" operator, it prints its arguments into the element. Arguments (or <em>tokens</em>) in dap rules are separated by whitespace.</p>


<h3>Status variables</h3>
<p>Status variables provide the main reactivity mechanism in dap. When a status variable gets changed, all elements that depend on it, are automatically updated. Status variables are prefixed with a <code>$</code>. Defined in element's status context, a variable is visible to all children of that element. Status variables can only be updated in u-rules.</p>
<pre lang="dap">
'cheese'.d("$value=" // d-rule defines a status variable named $value
	,'BUTTON'.d("! cheese").ui("$value=`cheeeeese!") // u-rules update the variable `
	,'INPUT placeholder="or type in here"'.d("!! $value").ui("$value=#:value")
	,'message'.d("! $value") // d-rule displays the variable
)
.DICT({
	cheese: "Say cheese!"
})
</pre>


<h3>Data entries</h3>
<p>Every generated element is bound to some data context, usualy it is a data row in some dataset. Data context can be shared among several elements, related to the same data row. Fields of a data row, or <em>data entries</em>, can be read and modified in both u- and d-rules. Data entries are not traced for changes and do not cause updates to other elements. In rules, data entries are prefixed with a <code>.</code> (dot). Data context scope is independent from status context scope.</p>
<pre lang="dap">
'colored-fruits'.d("$color= $fruit="
	,'UL.labelled'
		.a("!! (hint.fruit $fruit)concat@label")
		.d("* color"
			,'LI'.d("! (.color $fruit)sentence").ui("$color=.color")
		)
	,'UL.labelled'
		.a("!! (hint.color $color)concat@label")
		.d("* fruit"
			,'LI'.d("! ($color .fruit)sentence").ui("$fruit=.fruit")
		)
	,'BUTTON'.d("! hint.reset.color").ui("$color=")
	,'BUTTON'.d("! hint.reset.fruit").ui("$fruit=")
	,'message'.d("? ($color $fruit)!; ! (hint.choice $color $fruit)sentence:uppercase,glitzy")
)
.DICT({
	color:["red","orange","yellow","green"],
	fruit:["apple","pear","banana"],
	
	hint:{ // constants in the dictionary can be grouped...
		color: "Color: ",
		fruit: "Fruit: ",
		reset :{ // ...to arbitrary depth
			color: "Reset color",
			fruit: "Reset fruit"
		},
		choice: "Your choice is"
	}
})
.FUNC({
	flatten	:{
		sentence: values=>values.reverse().join(" ")
	},
	convert	:{
		uppercase: str=>str.toUpperCase(),
		glitzy: str=>"*** "+str+" ***"
	}
})
</pre>
<p>Here, all elements inside the <code>'colored-fruits'</code> share the same status context with <code>$color</code> and <code>$fruit</code> status variables defined in it. However, each <code>LI</code> element in the two lists has its own data context, containing one data entry, either <code>.color</code> or <code>.fruit</code></p>
<p>Another interesting point of this example is the <code>.FUNC</code> section (functionality) and the d-rule of <code>'message'</code> element. Meet: flatteners and convertors...</p>

<h3>Flatteners and convertors</h3>
<p>For data transformations, dap provides mechanism of <em>flatteners</em> and <em>covertors</em>. These are similar to Javascript functions. In fact, they ARE ordinary Javascript functions â€” but with imposed uniform contracts:</p>
<p>Convertors are <code>value=>value</code> functions, that is, they take a single value and return a single value. This contract allows to chain several convertors to be sequentially applied to a value, like <code>value:converter1,converter2,converterN</code> which is equiuvalent to <code>converterN(converter2(converter1(value)))</code> in Javascript notation. In the example above, the conversion chain <code>:uppercase,glitzy</code> first converts the input to upper case, then wraps it into the glitzy asterisks, as specified in the <code>.FUNC</code> section</p>
<p>Flatteners are <code>([values],[names])=>value</code> functions, or <code>[values]=>value</code> if names are not used. These functions allow to "flatten" arbitrary number or arguments into one single value. In the example above, the <code>()sentence</code> flattener builds up a sentence from several wordings, by simply stitching them with a space character between. This sentence (a single string) is then fed to the convertors.</p>
<p>Another flattener featuring in <code>'message'</code> d-rule is dap's standard <code>()!</code> flattener, that tests if ALL of its arguments are <i>truthy</i>. Its counterpart, <code>()?</code> flattener, that you will see in the example below, tests if ANY of its arguments is truthy.</p>

<h3>Named arguments</h3>
<p>Having argument names provided along with values gives some extra possibilities to the flatteners. For example, parameter strings (parameterized URLs being typical example) can be built easily.</p>
<pre lang="dap">
'stocks'.d("$code= $warehouse="
	,'INPUT placeholder="Item code"'.ui("$code=#:value")
	,'INPUT placeholder="Warehouse"'.ui("$warehouse=#:value")
	,'message'.d("? ($code $warehouse)?; ! hint (base@ $code $warehouse)uri")
)
.DICT({
	hint: "Constructed URI: ",
	base: "https://mygoods.com/getstocks.php?"
})
</pre>
<p>So, what new can we see here? A <code>#</code> special entry that evaluates to "this element" at run time, a standard <code>:value</code> converter that "converts" an element to its "value" (which is slightly different for various types of elements), and standard <code>()uri</code> flattener that "flattens" its arguments into a simple string using their values and names.</p>
<p>Names of arguments are normally taken from their identifiers. For <code>$foo</code> variable, or <code>.foo</code> data entry, of <code>foo</code> constant, the name will be "foo". If argument is dot-routed, the name will be the tail part of its route: for <code>$customer.details.address</code> the name will be simply "address". The argument's default name can be altered with the <code>@</code> aliaser. For example, <code>$customer.details.address@ship-to</code> will be named "ship-to".</p>
<p>Arguments can have empty names. By default, literals and flattened results have empty names, as they're not referred to by any indetifier. But they can be named explicitly, too: <code>@city`Moscow</code>, or <code>(.user.nickname .user.email)?@login</code>.</p>
<p>On the other hand, arguments named by default can be made "nameless", applying an empty aliaser to it. In the example above, <code>$code</code> and <code>$warehous</code> arguments of <code>()uri</code> flattener are named, and <code>()uri</code> treats them as URI parameters, that have to appear in the resulting URI string formatted as "&amp;name=value", while <code>base@</code> argument is nameless, so <code>()uri</code> does not treat it as  URI parameter, but inserts its value it as is.</p>

<h2>Working with external data</h2>
<p>Now that we can construct parameterized URIs, and can work with datasets, we can do requests for external data. With dap it is very simple with a standard <code>query</code> converter that "converts" an URL into result of a HTTP request to that URL:</p>
<pre lang="dap" data-style="height:16em">
'heroes'.d("$id= $name="
	,'UL'.d("* (heroes@)uri:query@" // query data from the URL, parse it and populate a dataset from it  
		,'LI.hero'
			.d("!! .name@ .id@title")
			.ui("$id=.id $name=.name")
	)
	,'message'.d("? $id; ! (message $id $name)here")
)
.DICT({
	heroes:"/samples/heroes.json",
	message:"Hero id: {id}\n Hero name: {name}"
})
</pre>
<p>Here, we get our data from a static file <a href="/samples/heroes.json">heroes.json</a> which contains some super-hero data in a JSON array. By the <code>query</code> convertor, this file is requested asynchronously, parsed (based on its content-type header) and fed to <code>*</code> operator, that populates <code>&lt;LI class="hero"&gt;</code> elements for each row in that rowset.</p>
<p>If you click a hero's name in the list, status variables <code>$id</code> and <code>$name</code> are updated with the hero's respective data, and the summary message updates to reflect these changes.</p>


<h2>Okay, what's next?</h2>
<p>By this point, you should be able to read dap rules and easily tell status variables from data entries, flatteners from converters, and guess the overall logic of a dap template.</p>


<img src="we_need_to_go_deeper.jpg" alt="But we need to go deeper" title="But we need to go deeper"/>

<p>Coming soon: writing a real-world dap application</p>

</body>

<script src="../0.4.js"></script>
<script src="dapify.js"></script>

</html>


