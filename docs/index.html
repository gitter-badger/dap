<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Understanding dap</title>
	<link href="styles.css" rel="stylesheet" type="text/css"/>	
</head>
<body>

<h1>Understanding dap</h1>
<p>All you need to use dap in your document is a reference to dap runtime script: <code>&lt;script src="https://dap.js.org/0.4.js"&gt;&lt;/script&gt;</code>. You can start your dap experiments with an .html document like this:</p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;My dap playground&lt;/title&gt;
  <b>&lt;script src="https://dap.js.org/0.4.js"&gt;&lt;/script&gt;</b>
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h2&gt;Welcome to dap&lt;/h2&gt;
  &lt;script&gt;
  
   // My dap code here
   
   .RENDER() // this method renders the dap template
   
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Save it on your Desktop (or anywhere else), then open in a web browser. Now you can simply copy-and-paste examples into this file, and refresh browser to see the examples working. Or, you can play with the code right here, all code samples are editable. Results of each code sample are shown under.</p>


<h2>Rules and contexts</h2>
<p>Elements rendered into DOM are generated from <em>dap-templates</em>. Every template defines element's a <em>signature</em> and <em>rules</em> for generated element. Signature designates the element's generic properties: tag, css class, other attributes. Rules define the element's behavior on different phases of its life cycle:</p>
<ul>
	<li><em>d-rule</em> is executed on "down" phase, when the document is populated, from root <i>down</i> to child elements</li>
	<li><em>a-rule</em> is accumulation rule, similar to d-rule, but appends changes to the existing element instead of building it anew</li>
	<li><em>u-rule</em> is executed on "up" phase, when an event bubbles through the element <i>up</i> to the root</li>
	<li><em>e-rule</em> is a variant of u-rule, that not only handles events, but generates them, too</li>
	<li><em>ui-rule</em> is a convenience variant of e-rule dealing with the element's default UI event</li>
</ul>
<p>Every generated element in a dap document is bound to two local contexts: <em>status context</em> and <em>data context</em>. Element's dap rules are executed within these contexts. Constants defined in a dictionary are visible to all elements.</p>

<h3>Literals and constants</h3>
<p>Literal values in dap rules are prefixed with a <code>`</code> (backtick) which can be found on your keyboard somewhere around Esc key. Literal values are not very welcome in dap rules and are usually used for numbers or other short codes. They cannot contain spaces, because spaces are delimeters between tokens within a rule. Textual content, as well as constant values of any other kind should be defined in the <code>.DICT</code> section (the dictionary) and referred to as constants, <code>good</code> in the example below. Keeping all constants grouped in one place helps make the code cleaner and maintainance easier. Dap is rather encouraging to that coding style.</p>
<pre class="dap">
'B'.d("! good `literals_in_rules_are_not_good_for_long_texts")
.DICT({ // this is the dictionary
	good:"The right place for text and other constants is the dictionary, "
})
</pre>
<p>Exclamation sign <code>!</code> in the beginning of the rule is a "print" operator, it prints its arguments into the element. Arguments (or <em>tokens</em>) in dap rules are separated by whitespace.</p>


<h3>Status variables</h3>
<p>Status variables provide the main reactivity mechanism in dap. When a status variable gets changed, all elements that depend on it, are automatically updated. Status variables are prefixed with a <code>$</code>. Defined in element's status context, a variable is visible to all children of that element. Status variables can only be updated in u-rules.</p>
<pre class="dap">
'cheese'.d("$value=" // d-rule defines a status variable named $value
	,'BUTTON'.d("! cheese").ui("$value=`cheeeeese!") // u-rules update the variable `
	,'INPUT placeholder="or type in here"'.d("!! $value").ui("$value=#:value")
	,'message'.d("! $value") // d-rule displays the variable
)
.DICT({
	cheese: "Say cheese!"
})
</pre>


<h3>Data entries</h3>
<p>Every generated element is bound to some data context, usualy it is a data row in some dataset. Data context can be shared among several elements, related to the same data row. Fields of a data row, or <em>data entries</em>, can be read and modified in both u- and d-rules. Data entries are not traced for changes and do not cause updates to other elements. In rules, data entries are prefixed with a <code>.</code> (dot). Data context scope is independent from status context scope.</p>
<pre class="dap">
'colored-fruits'.d("$color= $fruit="
	,'UL.labelled'
		.a("!! (hint.fruit $fruit)concat@label")
		.d("* color"
			,'LI'.d("! (.color $fruit)sentence").ui("$color=.color")
		)
	,'UL.labelled'
		.a("!! (hint.color $color)concat@label")
		.d("* fruit"
			,'LI'.d("! ($color .fruit)sentence").ui("$fruit=.fruit")
		)
	,'BUTTON'.d("! hint.reset.color").ui("$color=")
	,'BUTTON'.d("! hint.reset.fruit").ui("$fruit=")
	,'message'.d("? ($color $fruit)!; ! (hint.choice $color $fruit)sentence:uppercase,glitzy")
)
.DICT({
	color:["red","orange","yellow","green"],
	fruit:["apple","pear","banana"],
	
	hint:{ // constants in the dictionary can be grouped...
		color: "Color: ",
		fruit: "Fruit: ",
		reset :{ // ...to arbitrary depth
			color: "Reset color",
			fruit: "Reset fruit"
		},
		choice: "Your choice is"
	}
})
.FUNC({
	flatten	:{
		sentence: values=>values.reverse().join(" ")
	},
	convert	:{
		uppercase: str=>str.toUpperCase(),
		glitzy: str=>"*** "+str+" ***"
	}
})
</pre>
<p>Here, all elements inside the <code>'colored-fruits'</code> share the same status context with <code>$color</code> and <code>$fruit</code> status variables defined in it. However, each <code>LI</code> element in the two lists has its own data context, containing one data entry, either <code>.color</code> or <code>.fruit</code></p>
<p>Another interesting point of this example is the <code>.FUNC</code> section (functionality) and the d-rule of <code>'message'</code> element. Meet: flatteners and convertors...</p>

<h3>Flatteners and convertors</h3>
<p>For data transformations, dap provides mechanism of <em>flatteners</em> and <em>covertors</em>. These are ordinary Javascript functions â€” but with imposed uniform contracts:</p>
<p>Convertors are <code>value=>value</code> functions, that is, they take a single value and return a single value. This contract allows to chain several convertors to be sequentially applied to a value, like <code>value:converter1,converter2,converterN</code> which is equiuvalent to <code>converterN(converter2(converter1(value)))</code> in Javascript notation. In the example above, the conversion chain <code>:uppercase,glitzy</code> first converts the input to upper case, then wraps it into the glitzy asterisks, as specified in the <code>.FUNC</code> section</p>
<p>Flatteners are <code>([values],[names])=>value</code> functions, or <code>[values]=>value</code> if names are not used. These functions allow to "flatten" arbitrary number or arguments into a single value. In the example above, the <code>()sentence</code> flattener builds up a sentence from several wordings, by simply stitching them with a space character between. This sentence (a single string) is then fed to the convertors.</p>
<p>Another flattener featuring in <code>'message'</code> d-rule is dap's standard <code>()!</code> flattener, that tests if ALL of its arguments are <i>truthy</i>. Its counterpart, <code>()?</code> flattener, that you will see in the example below, tests if ANY of its arguments is truthy.</p>

<h3>Named arguments</h3>
<p>Having argument names provided along with values gives some extra possibilities to the flatteners. For example, parameter strings (parameterized URLs being typical example) can be built easily.</p>
<pre class="dap">
'stocks'.d("$code= $warehouse="
	,'INPUT placeholder="Item code"'.ui("$code=#:value")
	,'INPUT placeholder="Warehouse"'.ui("$warehouse=#:value")
	,'message'.d("? ($code $warehouse)?; ! hint (base@ $code $warehouse)uri")
)
.DICT({
	hint: "Constructed URI: ",
	base: "https://mygoods.com/getstocks.php?"
})
</pre>
<p>So, what new can we see here? A <code>#</code> special entry that evaluates to "this element" at run time, a standard <code>:value</code> converter that "converts" an element to its "value" (which is slightly different for various types of elements), and standard <code>()uri</code> flattener that "flattens" its arguments into a simple string using their values and names.</p>
<p>Names of arguments are normally taken from their identifiers. For <code>$foo</code> variable, or <code>.foo</code> data entry, of <code>foo</code> constant, the name will be "foo". If argument is dot-routed, the name will be the tail part of its route: for <code>$customer.details.address</code> the name will be simply "address". The argument's default name can be altered with the <code>@</code> aliaser. For example, <code>$customer.details.address@ship-to</code> will be named "ship-to".</p>
<p>Arguments can have empty names. By default, literals and flattened results have empty names, as they're not referred to by any indetifier. But they can be named explicitly, too: <code>@city`Moscow</code>, or <code>(.user.nickname .user.email)?@login</code>.</p>
<p>On the other hand, arguments named by default can be made "nameless", applying an empty aliaser to it. In the example above, <code>$code</code> and <code>$warehous</code> arguments of <code>()uri</code> flattener are named, and <code>()uri</code> treats them as URI parameters, that have to appear in the resulting URI string formatted as "&amp;name=value", while <code>base@</code> argument is nameless, so <code>()uri</code> does not treat it as  URI parameter, but inserts its value it as is.</p>

<h2>Working with external data</h2>
<p>Querying for external data is very simple with a standard <code>:query</code> converter that "converts" an URL into result of a HTTP request to that URL:</p>
<pre class="dap" data-style="height:16em">
'heroes'.d("$id= $name="
	,'UL'.d("* (heroes@)uri:query@" // query data from the URL, parse it and populate a dataset from it  
		,'LI.hero'
			.d("!! .name@ .id@title")
			.ui("$id=.id $name=.name")
	)
	,'message'.d("? $id; ! (message $id $name)here")
)
.DICT({
	heroes:"/samples/heroes.json",
	message:"Hero id: {id}\n Hero name: {name}"
})
</pre>
<p>Here, we get our data from a static file <a href="/samples/heroes.json">heroes.json</a> which contains some super-hero data in a JSON array. With the <code>:query</code> convertor, this file is asynchronously requested, parsed (based on its content-type header) and fed to <code>*</code> operator, that populates <code>&lt;LI class="hero"&gt;</code> elements for each row in that rowset.</p>
<p>If you click a hero's name in the list, status variables <code>$id</code> and <code>$name</code> are updated with the hero's respective data, and the summary message updates to reflect these changes.</p>

<h3>Making parameterized queries to external sources</h3>
<p>Now that we can work with datasets, construct parameterized URIs, and query external data, let's combine it all together, and build a car picker for a car parts shop.</p>
<p>Querying logic in the example below is straight-forward: first, user selects production year and maker from predefined lists (years array is generated immediatel in the DICT, and makes are taken from an external JSON file); then, for these year and make, a model list is queried from an external data source. Then, for selected model, a list of engines and corresponding car-codes is queried. Here, we use https://dapmx.org/stuff/rockauto.php endpoint, that is essentially an adapter to www.rockauto.com database, accepting URI-encoded queries and returning results in JSON format.</p>
<pre class="dap">
'carshop'.d("$carname= $carcode="
	,'car-picker'.d("$make= $year= $model= $engine="
		,'SPAN'.d(""
			,'SELECT.year'.d("Hint(label.year@label); * year" // years are taken immediately from DICT
				,'OPTION'.d("! .year")
			).ui("$year=#:value")
			,'SELECT.make'.d("Hint(label.make@label); * (makes@)uri:query@make" // makes are taken from a static file
				,'OPTION'.d("! .make")
			).ui("$make=#:value")
		).u("$model= $carcode=") // reset $model and $carcode, when make or year were changed 
		,'SELECT.model'.d("? ($make $year)!; Hint(label.model@label); * (base@ $make $year)uri:query@model" // models are queried parametrically for given make and year
			,'OPTION'.d("! .model")
		).ui("$model=#:value")
		,'SELECT.engine'.d("? $model; Hint(label.engine@label); * (base@ $make $year $model)uri:query" // carcodes are queried parametrically for given make, year and model
			,'OPTION'.d("!! .engine@ .carcode@value") // .engine name used as option content, .carcode used as option value
		).ui("$carcode=#:value")
	).u("$carname=( $carcode ( $year $make $model $engine )spaced )!") // $carname will be empty until $carcode is set
	
	,'H3'.d("! ($carname label.hint)?") // print $carname if set, otherwise a hint
	,'carcode'.d("? $carcode; ! label.carcode $carcode")
)
.DICT({
	year	: Array.from({length:20},(v,i)=>2019-i), // back to 20 years from year 2019
	makes	: "/samples/carmakes.json", // car makes are collected in a static file
	base	: "https://dapmx.org/stuff/rockauto.php?", // dynamic data is taken from Rockauto.com
	label	:{
		hint	: "Select a car, please",
		please	: "Please select",
		make	: "Car make",
		year	: "Production year",
		model	: "Model name",
		engine	: "Engine",
		carcode	: "Car code: "
	},
	Hint	: 'OPTION selected disabled'.d("! .label") // this is a reusable parameterized template
})
</pre>
<p>The new thing in the example above is a <em>reusable template</em> <code>Hint()</code> which is used in the several SELECT elements to display initial hints.</p>

<h3>Parameterized reusable templates</h3>
<p>Parameterized reusable templates to dap are essentially what functions are to Javascript. It is a means of code clarification by extracting repeated pieces of code into reusable entities, optionally with parameters. In dap, templates can be defined in the <code>.DICT</code> section, as any other data, and can be invoked from dap rules using brackets notation. Parameters provided to invoked templates become their data context.</p>
<p>A multi-level list of recursive structure is another good use case for reusable templates. Here is a sample of table of contents (for RFC7540, HTTP 2.0 specs), built from <a href="/samples/rfc7540contents.json" target="_blank">a JSON file</a>.</p>
<pre class="dap">
'contents'.d("List( (`/samples/rfc7540contents.txt)uri:query,untab.decode@items )") // root invokes List() for the top-level items
.DICT({
	List	:'OL'.d("* .items@; Item($)"), // List invokes Item() for each item in a rowset
	Item	:'LI'.d("! .heading; Href( .page); ? .items; List(.items)"), // Item invokes List() for its sub-items, if present
	Href	:'A.page target=rfc'.d("!! .page@ (`https://tools.ietf.org/html/rfc7540#page- .page)concat@href")
})
.USES({
	untab	:"/stuff/untab.js"
})
</pre>
<p>Here, the URL provides <a href="/samples/rfc7540contents.txt" target="_blank">data in a custom indented table format</a>, which is not JSON. Thus, the <code>:query</code> converter does not parse it automatically, but only performs a HTTP request and returns the response text "as is". To have it converted to a dataset, we use a <code>decode</code> converter from an external dap file, <a href="/stuff/untab.js">untab.js</a>, that converts indented text to a dataset object. Of course, we could simply have used <a href="/samples/rfc7540contents.json" target="_blank">an equivalent JSON file</a> instead, and wouldn't need an extra convertor then... But I thought, it is a good chance to introduce you to <i>namespaces</i>.


<h3>Namespaces</h3>
<p>Namespaces allow to reuse dictionaries and functionalities from other dap files. Somewhat similar to namespaces in Java or C#, or modules in Javascript, but simpler. To gain access to the dictionary and functionality of external dap file, you simply reference it in the <code>.USES</code> section.</p>
<!--
<pre>
'reusable'.d("! welcome")
.DICT({
	welcome	: "Hello from Reusable.js\n",
	
})
.FUNC({
	convert	:{
		underscored : text=>"_"+text+"_"
	}
})
</pre>

<pre>
'sample'.d("! welcome:re.underscored re.welcome")
.DICT({
	welcome	: "Hello from inside the Sample",
})
.USES({
	re	:"Reusable.js"
})
</pre>
-->

<h3>Okay, what's next?</h3>

<img src="we_need_to_go_deeper.jpg" alt="But we need to go deeper" title="But we need to go deeper"/>

<p>Coming soon: writing a real-world dap application</p>

</body>

<!--
<script src="https://cdn.jsdelivr.net/gh/jooher/dap/0.4.min.js"></script>
-->
<script src="../0.4.js"></script>
<script src="../stuff/dapify.js"></script>

<link href="/stuff/talks.css" rel="stylesheet" type="text/css"/>	
<script src="/stuff/talks.js#msg=7"></script>

</html>


