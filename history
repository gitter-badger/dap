Хочу рассказать про dap — интересный и необычный язык реактивных правил для написания, в частности, веб-фронтендов.

Для затравки простая задачка: взять список неких сказочных персонажей (список позаимствован из туториала по Angular) по адресу https://dap.js.org/samples/heroes.json и вывести их имена обычным html-списком; при нажатии на имя героя — писать его id в консоль. 

Это, конечно, легко делается и на React, и на Angular, и на Vue. Вопрос: <i>насколько</i> легко? В dap это делается так:

<source lang="javascript">
'UL.heroes'.d("* :query`https://dap.js.org/samples/heroes.json"
	,'LI'.d("! .name").ui("log .id")
)
</source>

Это первая пришедшая в голову тривиальная задачка и тривиальный же способ ее решения. На dap удобно писать "в лоб", не городя огород из  классов, компонентов и прочего ритуального реквизита. Что вижу, то пою. Но "пою" не на javascript или его производных, а на языке <b>dap-правил</b>, специально заточенном на простое и лаконичное описание реактивных зависимостей между элементами.

В примере выше, правда, никаких зависимостей пока нет. Зато есть:

<ul>
	<li>оператор <code>*</source> для итерации по данным,</li>
	<li>конвертер <code>:query</source> для асинхронной "конвертации" урла в полученные с него данные,</li>
	<li>оператор <code>!</source> для "печати" в генерируемый элемент,</li>
	<li>оператор <code>log</source> для вывода в консоль.</li>
</ul>

Если вы знакомы с HTML, то слова UL и LI вам, вероятно, известны. Да, это теги для ненумерованного списка и для элемента списка, соответственно. А если и CSS вам не чужд, то и смысл записи UL.heroes вам должен быть понятен: это элемент UL с классом "heroes". На HTML это писалось бы <code>&lt;UL class="heroes"&gt;</source>, но нам эти сложности с атрибутами и угловыми скобками ни к чему — dap использует лаконичную нотацию, очень похожую на CSS. Хотя и атрибуты при надобности в этой нотации возможны, например: <code>'FORM action=send.php method=post'</source>.

Кстати: вы заметили, что этот пример написан на обычном javascript, а сами dap-правила это просто строки? И сигнатуры элементов ("теги") — тоже строки, просто в одинарных кавычках. Да, код dap-приложения выглядит непривычно, но это — чистый javascript, готовый к употреблению: его не нужно транспилировать из исходников на новомодных языках (что, конечно, не помешает вам этими модными языками пользоваться при желании).

Чуть усложним задачку, добавив зависимостей: пусть при нажатии на героя его id и name отображаются крупненько в элементе H2, а под ним пусть будет TEXTAREA с некой инфой по данному герою, которая берется с сервера по адресу https://dap.js.org/samples/hero-info.php?id={id выбранного героя}. И вот еще: чтобы эту инфу можно было править и отправлять обратно на сервер. Вот так вот сразу.

<source lang="javascript">
'heroes'.d("$hero="
	,'UL'.d("* :query`https://dap.js.org/samples/heroes.json"
		,'LI'.d("! .name").ui("$hero=$")
	)
	,'H2'.d("! $hero.id `: $hero.name")
	,'TEXTAREA'
		.d("! (`https://dap.js.org/samples/hero-info.php? $hero.id)uri:query")
		.ui("( (`https://dap.js.org/samples/hero-info.php? $hero.id #:value@info)post:query `Saved `Failed)?!:alert")
)
</source>

Здесь уже имеем зависимость содержимого элементов H2 и TEXTAREA от того, какой герой выбран. Выбранный герой, таким образом, оказывается переменной состояния. Такие переменные в dap-правилах обозначаются префиксом <code>$</code> (как s в "state"). При нажатии на любой из элементов LI изменяется содержимое переменной <code>$hero</code>, на что элементы H2 и TEXTAREA автоматически реагируют и обновляются. Каким образом H2 и TEXTAREA узнают, что надо бы обновиться? Очень просто: в их правилах генерации присутствует обращение к переменной <code>$hero</code>, а в правиле реакции элемента LI эта переменная как раз и изменяется.

Правила генерации — те, которые указываются с помощью метода <code>.d</code> — исполняются на фазе построения элемента. Правила реакции задаются методом <code>.ui</code> и исполняются при взаимодействии пользователя с элементом. Это два самых часто употребимых типа правил; кроме них есть еще несколько типов, но о них как-нибудь потом.

Синтаксис dap-правил довольно специфичен. Он не имеет ничего общего с всем привычным C-подобным синтаксисом, поэтому поначалу может казаться странным и непонятным. Но на самом деле он исключительно прост и, не побоюсь этого слова, прекрасен.

В языке нет ключевых слов. Зарезервированы символы <code>.,$@:`(){}</code> и пробел, все остальное может использоваться свободно. В частности, идентификаторы могут содержать, или состоять целиком, например, из символов !?* и т.п. Кому-то это покажется дикостью, но на деле это очень, очень удобно. Например, самыми часто используемыми в dap являются операторы (кстати, имена операторов — тоже идентификаторы):

<ul>
	<li><code>!</code> - вывод значения, что-то вроде <i>print</i></li>
	<li><code>?</code> - условный оператор, что-то вроде <i>if</i></li>
	<li><code>*</code> - мультиплексор, или итератор, что-то вроде <i>for</i></li>
</ul>

Имена штатных операторов намеренно выбраны такими — невербальными. Во-первых, они просто короче — всего один символ. Во-вторых, хорошо отличимы от, скажем, имен констант и переменных. Ну и наконец, они нейтральны к локали и одинаково уместно выглядят в программах на любом национальном языке, хоть английском, хоть русском, хоть китайском (благо, javascript и unicode это позволяют).

А кто не сталкивался с ситуацией, когда сидишь и тупишь, придумывая имя для переменной? Хотите верьте, хотите нет, в моем dap-коде практически все "булевы" (да/нет) переменные именуются <code>$?</code> (где <code>$</code> — это префикс переменной состояния, а собственно имя состоит просто из знака вопроса). Мне просто лень придумывать им имена, а потом еще и печатать их в нескольких местах. При этом никогда не возникает никаких сложностей с пониманием, что эта переменная означает в каждом конкретном месте: благодаря компактности и обозримости dap-кода, вся область действия такой переменной обычно умещается в несколько строк, и всегда понятно что к чему.

<source lang="javascript">
'toggle'.d("$?=" // define $? and set its value to 'nothing', sort of false
	,'BUTTON'.d("! `Toggle").ui("$?=$?:!") // on click, negate $?, as in x=!x
	,'on'.d("? $?; `✓") // show check mark if $? is set
)
</source>

Разумеется, это всего лишь мой личный стиль. Если вы пришли из мира Enterprise Java, не беспокойтесь: никто не запретит вам использовать сколь угодно длинные идентификаторы в любом месте. Чего нельзя сказать о литералах.

Литералы в dap-правилах обозначаются префиксом <code>`</code> (backtick, на клавиатурах обычно под клавишей Esc). Например, элемент BUTTON в примере выше подписан литералом <code>`Toggle</code>. В отличие от других, "нормальных" языков, где, скажем, строковые литералы заключаются в кавычки и могут содержать приличные объемы текста, в dap-правилах литералы обрамляются только с одной стороны (тем самым префиксом <code>`</code>), и не могут содержать пробелов, т.к. пробел служит разделителем токенов ("аргументов") в правиле. Как же так, спросите вы? А вот так. Литералы в dap предназначены не для эпистолярных фрагментов, а для различных коротких кодов: номеров, меток, каких-то отладочных заглушек и.п. Текстовые данные (как, впрочем, и любые другие) dap настойчиво требует хранить в виде констант в специальном словаре, в секции <code>.DICT</code> (от "dictionary", понятное дело):

<source lang="javascript">
'whoami'.d("$fruit="
	'H3'.d("! ($fruit msg.fruit-selected msg.please-select)?! $fruit")
	'UL'.d("* fruit"
		,'LI'.d("! .fruit").ui("$fruit=.")
	)
)
.DICT({
	msg	:{
		"please-select": "Кто я? Зачем я в этом мире?",
		"fruit-selected": "Я — "
	},
	fruit	:["Апельсинчик, сочный витаминчик", "Яблочко зеленое, солнцем напоённое", "Cлива лиловая, спелая, садовая", "Абрикос, на юге рос"]
})
</source>

Очевидным преимуществом хранения всех текстов в словаре является, например, легкость последующих локализаций на другие языки.

Но в словаре хранятся не только текстовые данные, а вообще любые повторно используемые сущности. В том числе, параметризуемые шаблоны, или "компоненты", как их называют в других фреймворках:

<source lang="javascript">
'multiselect'.("$color= $size="
	,'H3'.d("! (($color $size)? (selected $color $size)spaced not-selected)?!")
	,'size'.d("$!=select(sizes@options)").u("$size=$!.value")
	,'color'.d("$!=select(colors@options)").u("$color=$!.value")
)
.DICT({
	select: 'SELECT'.d("* .options@value"
			,'OPTION'.d("!! .value")
		).ui(".value=#:value"),
		
	sizes: ["XS","S","M","L","XL"],
	colors: "white black brown yellow pink".split(" "),// when you're lazy
	
	"not-selected": "Select size and color please",
	selected: "Selected specs:"
})
</source>

В принципе, ничто не мешает вообще все приложение разбить на "компоненты" и запихнуть в словарь, если вам нравится такой стиль:

<source lang="javascript">
'main'.d("! header content footer")
.DICT({
	header	:	'HEADER'.d(...),
	content	:	'UL.menu'.d(...),
	footer	:	'FOOTER'.d(...)
})
</source>

Я, правда, в этом смысла особого не вижу, и обычно выношу в словарь только те фрагменты, которые реально используются многократно.

Кстати, поскольку это все еще обычный javascript, а собственно словарь — это, как можно видеть, просто объект (или, как их называют, ассоциативный массив), то и формировать его можно любым легальным для javascript способом. Например, в примере чуть выше массив значений для константы <code>colors</code> генерируется из строки с помощью метода <ahref="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split">split</a>. Можно вообще весь объект для словаря импортировать из внешнего скрипта-библиотеки любым доступным способом — хоть по старинке через <code>&lt;script src="..."&lt;</code> или XHR->eval(), хоть через <code>import</code> (но убедитесь, что ваши клиенты этот новомодный способ поддерживают). Секций <code>.DICT</code> может быть несколько, все они объединяются в один общий словарь.

<source lang="javascript">
const lib1={
		message: "Hello from lib1"
	},
	lib2={
		message: "Hi from lib2"
	};
	

'my-app'.d("! message wrapped.message imported.message")

.DICT(lib1)
.DICT({
	wrapped: lib2,
	imported: import "extern.js";
})

//файл extern.js
({
	message: "Bonjour de lib importé"
})
</source>

Помимо штатных средств javascript, для подключения внешних библиотекв в dap имеется и свой механизм. Отличие его в том, что библиотеки подгружаются лениво — только тогда, когда действительно нужно что-то из библиотеки взять. Такие библиотеки указываются в секции <code>.USES</code>

<source lang="javascript">
'main'.d("$?=" // unset $? 
	,'BUTTON.toggle'.ui("$?=$?:!") // toggle $?
	,'activated'.d("? $?" // only show when $? is set
		,'imported'.d("! delayed.message") // now print the message from the lib
	)
)
.USES({
	delayed: "extern.js"
})
</source>

Здесь библиотека extern.js загрузится только после нажатия кнопки, когда потребуется отобразить элемент 'imported' — а для этого распарсить и скомпилировать его dap-правило, которое и ссылается на внешнюю библиотеку.

Да, dap-правила "компилируются" перед исполнением. Причем лениво, только при первом фактическом обращении к шаблону элемента. Эта ленивость позволяет "размазать" компиляцию большого приложения на множество мелких этапов, и не занимать ресурсы браузера неиспользуемыми участками кода. Конечно, актуальна такая забота о ресурсах только для каких-то совсем уж больших приложений, или слабых устройств. В целом могу сказать, что dap молниеносен (в масштабах UX, конечно) — и в компиляции, и в исполнении. Производительность можно контролировать в консоли браузера: там логируется время каждой реакции.

Единственные заметные задержки, которые реально могут возникать — это задержки сети. Но и эти задержки не блокируют dap-приложение. Веб-запросы, исполняемые конвертором <code>:query</code> асинхронны и не задерживают отображение и работу остальных элементов.

Кстати, что такое <i>конвертор</i>? Конвертор в dap — это просто функция вида <i>value → value</i>, то есть с одним входом и одним выходом. Такое ограничение позволяет строить из конверторов цепочки, например выражение <code>$a:x,y,z</code> соответсвует <code>z(y(x($a)))</code> в си-подобной записи. То, что вход у конвертора всего один, казалось бы, ограничивает его возможности по сравнению с "обычной" функцией. Но это не так. Конвертор может принимать и отдавать как элементарные значения, так и объекты/массивы (в javascript разница между этими понятиями размыта), содержащие любое количество данных. Таким образом, конверторы в dap полностью заменяют "традиционные" функции, при этом могут собираться в цепочки и могут быть асинхронными, не требуя при этом никакого дополнительного синтаксического оформления.

Традиционных "функций" с фиксированным списком параметров в dap, соответственно, нет — за ненадобностью.

Зато есть еще <i>агрегаторы</i> — функции от произвольного числа аргументов (обычно равноправных, но не всегда). Например, агрегатор <code>()?</code> возвращает первый непустой аргумент или самый последний (аналог ||-цепочки в javascript), а агрегатор <code>()!</code> — наоборот, первый пустой аргумент, или самый последний (аналог &&-цепочки в javascript). Или, например, агрегатор <code>()uri</code> — строит из аргументов параметризованный URI.

И последний тип функций в dap - это операторы. Если конверторы и агрегаторы идеологически ближе к "чистым" функциям, которые просто вычисляют значения (хоть и не всегда это так), то задача операторов — применять эти значения к генерируемому элементу (например, оператор <code>!</code> добавляет значение аргумента к содержимому элемента, а оператор <code>!!</code> устанавливает атрибуты элемента) или управлять ходом исполнения правила (как, например, условный оператор <code>?</code>)

Арсенал штатных конверторов, агрегаторов и операторов в dap минимален, но это не важно. Главное, что вы можете создавать свои! Это важный момент. Нужно четко понимать, что сам язык dap-правил вовсе не претендует на роль универсального языка программирования, он только описывает зависимости между элементами. Подразумевается, что хардкор и вычисления реализуются нативными средствами среды (для браузера, это, понятно, javascript) а dap играет сугубо "логистическую" роль — указывая, что, когда и из чего нужно делать и куда отдавать.

Собственный функционал описывается в секции <code>.FUNC</code> (от "functionality"):

<source lang="javascript">
'staff'.d("$department="

	,'SELECT'.d("*@value url.depts:query,one-per-line"
		,'OPTION'.d("!! .value") // записать в атрибут value
	).ui("$department=#:value")
	
	'UL'.d("* (url.staff@ $department)uri:query" // для списка получить инфу по сотрудникам выбранного отдела
		,'LI.person'.d("!! .description@title" // LI для каждого сотрудника, в атрибуте title некое его описание
			,'name'.d("! (.firstname .middlename .lastname)spaced") // вывести ФИО через пробел
			,'contact'.d("! ((.phone .skype .email .postal)first-available no-contact)?") // и какой-нибудь один контакт
		)
	)
)
.DICT({
	url	: (base=>({
			depts: base+"/departments.txt",
			staff: base+"/staff.php?"
		}))("https://dapmx.org")
})
.FUNC({
	convert:{
		"one-per-line": text=>text.split(/\n/g) // разбить текст на массив строк
	},
	flatten:{
		"first-available": (values,names)=>{ // агрегатору передаются значения и имена аргументов
			for(let i=values.length;i--;) // из всех аргументов (передаются в обратном порядке)
				if(values[i]) // найти первый непустой аргумент
					return names[i]+": "+values[i]; // и вернуть его вместе с именем
		}
	}
})
.DICT({
	"no-contact": "No contacts available for this person"
})
</source>

Здесь собственный функционал тривиален, поэтому написан непосредственно "по месту". Разумеется, что-то более сложное имеет смысл писать самостоятельным модулем, а в <code>.FUNC</code> прописывать только протокол взаимодействия между этим модулем и dap. Скажем, в примере с игрой в крестики-нолики https://dap.js.org/samples/tictactoe.html (по мотивам React-туториала), вся логика игры описана в отдельном замыкании, а dap только связывает эту логику с картинкой на экране.




Да, вот еще что. Все это великолепие в сжатом виде весит ни много ни мало 9 кБ. Девять(!) килобайт.

Подробнее познакомиться с dap можно на https://dap.js.org