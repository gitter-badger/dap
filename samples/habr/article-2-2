Это вторая, заключительная, часть туториала, в котором мы пишем TodoMVC-клиент с помощью минималистичного реактивного js-фреймворка <a href="https://dap.js.org/">dap</a>.

Краткое содержание <a href="https://habr.com/en/post/480912/">первой части</a>: мы получили с сервера список дел в формате JSON, построили из него HTML-список, добавили возможность редактирования названия и признака завершенности для каждого дела, и реализовали уведомление сервера об этих редактированиях.

Осталось реализовать: удаление произвольных дел, добавление новых дел, массовую установку/сброс и фильтрацию дел по признаку завершенности и функцию удаления всех завершенных дел. Этим мы и займемся. Финальный вариант клиента, к которому мы придем в этой статье, можно посмотреть <a href="https://dap.js.org/samples/tutorial/7-3.html">здесь</a>.

<cut/>

Вариант, на котором мы остановились в прошлый раз, можно освежить в памяти <a href="https://dap.js.org/samples/tutorial/7-3.html">здесь</a>.

Вот его код:

<source lang="javascript">
'#todoapp'.d(""
  ,'#header'.d(""
    ,'H1'.d("")
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'.d("")
  )
  ,'#main'.d(""
    ,'#toggle-all type=checkbox'.d("")
    ,'UL#todo-list'.d("*@ todos:query"
      ,'LI'.d("$completed=.completed $editing= $patch=; a!"

        ,'INPUT.toggle type=checkbox'
          .d("#.checked=.completed")
          .ui("$patch=($completed=#.checked)")

        ,'LABEL.view'
          .d("? $editing:!; ! .title")
          .e("dblclick","$editing=`yes")

        ,'INPUT.edit'
          .d("? $editing; !! .title@value")
          .ui("$patch=(.title=#.value)")
          .e("blur","$editing=")

        ,'BUTTON.destroy'.d("")
      )
      .a("!? $completed $editing")
      .u("? $patch; (@method`PATCH .url:dehttp headers $patch@):query $patch=")
    )
  )
  ,'#footer'.d(""
    ,'#todo-count'.d("")
    ,'UL#filters'.d(""
      ,'LI'.d("")
    )
    ,'#clear-completed'.d("")
  )
)
.DICT({
  todos  : "//todo-backend-express.herokuapp.com/",
  headers: {"Content-type":"application/json"}
})
.FUNC({
  convert:{
    dehttp: url=>url.replace(/^https?\:/,'')
  }
})
.RENDER()
</source>

Сейчас здесь всего полсотни строк, но к концу статьи их станет вдвое больше - аж 100. Будет много HTTP запросов к серверу, поэтому откройте, пожалуйста, инструменты разработчика (в Хроме это, как вы помните, Ctrl+Shift+I) - там будет интересна в первую очередь вкладка Network, и во вторую - Console. Также не забываем просматривать код каждой версии нашей странички - в Хроме это Ctrl+U.

Тут я должен сделать небольшое лирическое отступление. Если вы не читали <a href="https://habr.com/en/post/480912/">первую часть</a> туториала, я бы рекомендовал все же начать с нее. Если вы ее читали, но ничего не поняли - лучше прочитать еще раз. Как показывают комментарии к предыдущим двум моим статьям, синтаксис и принцип работы dap не всегда сразу понятны неподготовленному читателю. Еще статья не рекомендуется к прочтению лицам, испытывающим дискомфорт при виде не си-подобного синтаксиса.

<img src="https://habrastorage.org/webt/wj/-n/br/wj-nbrh5eflirkcich69glgnooo.jpeg" />

Эта, вторая, часть туториала будет чуть сложней и интересней, чем первая. <i>[TODO: попросить @token найти в интернетах картинку с взрывающимся мозгом школьника]</i>.

С вашего позволения, нумерацию глав продолжу с ч.1. Там мы досчитали до 7. Итак,

<h2>8. Делаем список дел переменной состояния</h2>
Для удаления дела из списка есть кнопка <code>BUTTON.destroy</code>. Удаление заключается в отправке серверу DELETE-запроса и собственно удалении с глаз долой соответствующего элемента <code>UL#todo-list > LI</code> со всем содержимым. С отправкой DELETE-запроса все понятно:

<source lang="javascript">
        ,'BUTTON.destroy'.ui("(@method`DELETE .url:dehttp):query")
</source>
        
А вот с удалением элемента с экрана возможны варианты. Можно было бы просто ввести еще одну переменную состояния, скажем, <code>$deleted</code>:

<source lang="javascript">
     ,'LI'.d("$completed=.completed $editing= $patch= $deleted=; a!" // Переменная $deleted как признак "удаленности"
        ...
        ,'BUTTON.destroy'.d("(@method`DELETE .url:dehttp):query $deleted=`yes") // включили $deleted - вроде как бы удалили
      )
      .a("!? $completed $editing $deleted") // а в CSS прописать .deleted{display:none}
</source>

И это бы как бы работало. Но было бы читерством. К тому же, дальше по курсу у нас будут фильтры и счетчики активных и завершенных дел (то, что находится в <code>#footer</code>). Поэтому, лучше будем сразу удалять объект из списка дел по-честному, "физически". То есть нам нужна возможность модифицировать сам массив, который мы изначально получили от сервера - значит, этот массив тоже должен стать переменной состояния. Назовем ее <code>$todos</code>.

Областью определения переменной <code>$todos</code> нужно выбрать общего предка всех элементов, которые будут к этой переменной обращаться. А обращаться к ней будут и <code>INPUT#new-todo</code> из <code>#header</code>, и счетчики из <code>#footer</code>, и собственно <code>UL#todo-list</code>. Общий предок у них у всех - это корневой элемент шаблона, <code>#todoapp</code>. Следовательно, в его d-правиле и будем определять переменную <code>$todos</code>. Там же сразу и загрузим в нее данные с сервера. И строить список UL#todo-list тоже теперь будем из нее:

<source lang="javascript">
'#todoapp'.d("$todos=todos:query" // Объявляем переменную $todos и загружаем в нее данные
      ...
    ,'UL#todo-list'.d("*@ $todos" // Строим список уже из $todos	
</source>

<a href="https://dap.js.org/samples/tutorial/8-1.html">Смотрим</a>. Здесь <code>$todos</code> <i>объявлена</i> в d-правиле элемента <code>#todoapp</code> и сразу же <i>инициализирована</i> нужными данными. Вроде бы все работает, но появилась одна неприятная особенность. Если сервер долго отвечает на запрос (Chrome позволяет смоделировать такую ситуацию: на вкладке Network инструментов разработчика можно выбрать разные режимы имитации медленных сетей), то наша новая версия приложения до завершения запроса выглядит несколько печально - на экране нет ничего, кроме каких-то CSS-артефактов. Такая картина определенно не добавит энтузиазма пользователю. Хотя предыдущая версия <a href="https://dap.js.org/samples/tutorial/7-3.html"></a> этим не страдала - до получения данных на странице отсутствовал только сам список, но другие элементы появлялись сразу, не дожидаясь данных.

Дело вот в чем. Как вы помните, конвертор <code>:query</code> - асинхронный. Асинхронность эта выражается в том, что до завершения запроса блокируется только исполнение текущего правила, то есть генерация элемента, которому, собственно, запрашиваемые данные и нужны (что логично). Генерация же других элементов не блокируется. Поэтому, когда к серверу обращался <code>UL#todo-list</code> - блокировался только он, но не <code>#header</code> и не <code>#footer</code>, которые отрисовывались сразу. Теперь же завершения запроса ждет весь <code>#todoapp</code>.

<h2>9. Отложенная загрузка данных</h2>
Чтобы исправить ситуацию и избежать блокировки непричастных элементов, отложим первоначальную загрузку данных до момента, когда все уже отрисовалось. Для этого не будем сразу же загружать в переменную <code>$todos</code> данные, а сначала просто проинициализируем ее "ничем"

<source lang="javascript">
'#todoapp'.d("$todos=" // Объявляем переменную $todos и инициализируем ее "ничем"
</source>

Так она не будет ничего блокировать и весь шаблон отработает - пусть пока и с пустым "списком дел". Зато теперь, с нескучным начальным экраном, можно спокойно <i>модифицировать</i> <code>$todos</code>, загрузив-таки в нее список дел. Для этого добавим к <code>#todoapp</code> вот такого потомка:

<source lang="javascript">
  ,'loader'
    .u("$todos=todos:query") // модифицируем $todos, загружая в нее данные с сервера
    .d("u") // запустить реакцию (u-правило) сразу после генерации
</source>

Этот элемент имеет u-правило, которое выглядит точно так же, как и то блокирующее, от которого мы отказались, но здесь есть одно принципиальное отличие.
Напомню, что d-правило (от <i>down</i>) - это правило генерации элемента, которое исполняется при построении шаблона сверху <i>вниз</i>, от родителя к потомкам; а u-правила (от <i>up</i>) - это правила реакции, исполняемые в ответ на событие, всплывающее снизу <i>вверх</i>, от потомка к родителю.
Так вот, если переменной что-то (в т.ч. "ничто") присваивается <b>в d-правиле</b>, это означает ее <i>объявление и инициализацию</i> в области видимости данного элемента и его потомков (в dap реализованы вложенные области видимости, как и в JS). Присваивание же <b>в up-правилах</b> означает <i>модификацию</i> переменной, объявленной ранее в области видимости. Объявление и инициализация переменных в d-правиле позволяет родителю передавать потомкам вниз по иерархии информацию, необходимую для построения, а модификация - позволяет передавать наверх обновления этой информации и таким образом инициировать соответствующую перестройку всех элементов, от нее зависящих.

Элемент <code>loader</code>, будучи потомком <code>#todoapp</code>, в своем u-правиле <b>модифицирует</b> переменную <code>$todos</code>, загружая в нее данные с сервера, что вызывает автоматическую перегенерацию всех элементов-потребителей этой переменной (и только их, что важно!). Потребители переменной - это элементы, d-правила которых содержат эту переменную в качестве rvalue, т.е. те, кто <b>читают</b> эту переменную (с учетом области видимости) при построении.

Потребитель переменной <code>$todos</code> у нас сейчас один - тот самый <code>UL#todo-list</code>, который, соответственно, и будет перестроен после загрузки данных.

<source lang="javascript">
    ,'UL#todo-list'.d("*@ $todos" // вот он, потребитель переменной $todos	
</source>

Итак,  <a href="https://dap.js.org/samples/tutorial/9.html">теперь</a> у нас список дел является переменной состояния в <code>#todoapp</code>, при этом не блокируя первоначальной отрисовки шаблона.

<h2>10. Удаление и добавление дел</h2>
Теперь мы можем <code>$todos</code> всячески модифицировать. Начнем с удаления элементов. У нас уже есть кнопка-крестик <code>BUTTON.destroy</code>, которая пока просто отсылает серверу запросы на удаление:

<source lang="javascript">
        ,'BUTTON.destroy'.ui("(@method`DELETE .url:dehttp):query")
</source>

Надо сделать так, чтобы соответствующий объект удалялся и из переменной <code>$todos</code> - а поскольку это будет модификацией, то <code>UL#todo-list</code>, как потребитель этой переменной, автоматически перестроится, но уже без удаленного элемента.

Сам по себе dap не предоставляет никаких особых средств для манипуляций с данными. Манипуляции можно прекрасно писать в функциях на JS, а dap-правила просто доставляют им данные и забирают результат. Напишем JS-функцию удаления объекта из массива, не зная его номер. Например, такую:

<source lang="javascript">
const remove = (arr,tgt)=> arr.filter( obj => obj!=tgt );
</source>

Можно, наверно, написать и что-то более эффективное, но речь сейчас не про это. Вряд ли нашему приложению придется работать со списками дел из миллионов пунктов. Важно только то, что функция возвращает новый объект-массив, а не просто удаляет элемент из того что есть.

Чтобы сделать эту функцию доступной из dap-правил, ее нужно добавить в секцию .FUNC, но перед этим решить, как мы хотим ее вызывать. Самый простой вариант в данном случае, пожалуй, вызвать ее из конвертора, принимающего объект <code>{ todos, tgt }</code> и возвращающего отфильтрованный массив:

<source lang="javascript">
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''), // это здесь еще с первой части туториала
    remove: x => remove(x.todos,x.tgt) // удалить объект из массива
  }
})
</source>

но ничто не мешает определить эту функцию прямо внутри <code>.FUNC</code> (я уже говорил, что <code>.FUNC</code> - это на самом деле обычный JS-метод, а его аргумент - обычный JS-объект?) 

<source lang="javascript">
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''),
    remove: x => x.todos.filter( todo => todo!=x.tgt )
  }
})
</source>

Теперь мы можем обращаться к этому конвертору из dap-правил:

<source lang="javascript">
        ,'BUTTON.destroy'
	    .ui("$todos=($todos $@tgt):remove (@method`DELETE .url:dehttp):query")
</source>

Здесь мы сначала формируем объект, который в JS-нотации соответствует <code>{ todos, tgt:$ }</code>, передаем его конвертору <code>:remove</code>, описанному в <code>.FUNC</code>, а полученный отфильтрованный результат возвращаем в <code>$todos</code>, таким образом модифицируя ее. Здесь <code>$</code> - это <i>контекст данных</i> элемента, тот объект-дело из массива <code>$todos</code>, на котором построен шаблон. После символа <code>@</code> указывается псевдоним (alias) аргумента. Если <code>@</code> отсутствует, то используется собственное имя аргумента. Это похоже на недавнее нововведение ES6 - <a href="http://es6-features.org/#PropertyShorthand">property shorthand</a>.

Аналогичным образом делаем добавление нового дела в список, с помощью элемента <code>INPUT#new-todo</code> и POST-запроса:

<source lang="javascript">
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")
	...
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''),
    remove: x => x.todos.filter( todo => todo!=x.tgt ), // удалить объект из массива
    insert: x => x.todos.concat( [x.tgt] ) // добавить объект в массив
  }
})
</source>

Правило реакции элемента <code>INPUT#new-todo</code> на стандартное UI-событие (для элементов <code>INPUT</code> стандартным dap считает событие <code>change</code>) включает: чтение пользовательского ввода из свойства <code>value</code> этого элемента, формирование локального контекста <code>$</code> с этим значением в качестве поля <code>.title</code>, отправку контекста <code>$</code> серверу методом POST, модификацию массива <code>$title</code> добавлением контекста <code>$</code> в качестве нового элемента и наконец, очистку свойства <code>value</code> элемента <code>INPUT</code>.

Здесь юный читатель может спросить: зачем при добавления элемента в массив использовать <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat"><code>concat()</code></a>, если это можно сделать с помощью обычного <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a>? Опытный же читатель сразу поймет в чем дело, и напишет свой вариант ответа в комментариях.

Смотрим, что  <a href="https://dap.js.org/samples/tutorial/10-1.html">получилось</a> Дела добавляются и удаляются нормально, соответствующие запросы серверу отправляются исправно (вы же держите вкладку Network открытой все это время, верно?). Но что если мы захотим изменить название или статус свежедобавленного дела? Проблема в том, что для уведомления сервера об этих изменениях нам потребуется <code>.url</code>, который назначает этому делу сервер. Мы, когда дело создавали, его <code>.url</code> не знали, соответственно, корректный PATCH-запрос на изменение сформировать не можем.
На самом деле, вся необходимая информация о деле содержится в ответе сервера на POST-запрос, и корректней было бы новый объект-дело создавать не просто из пользовательского ввода, а из ответа сервера, и в <code>$todos</code> добавлять уже этот объект - со всей предоставляемой сервером информацией, в том числе и полем <code>.url</code>:

<source lang="javascript">
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$todos=($todos (@method`POST todos@url headers (#.value@title)):query@tgt ):insert #.value=")
</source>

Смотрим <a href="https://dap.js.org/samples/tutorial/10-2.html"></a> - окей, теперь все отрабатывается корректно. Уведомления серверу о редактировании свежесозданных дел уходят правильные.

Можно было бы на этом и остановиться, но... Но если приглядеться, то все же можно заметить небольшую задержку между вводом названия нового дела и моментом его появления в списке. Эту задержку хорошо заметно, если включить имитацию медленной сети. Как вы уже догадались, дело в запросе к серверу: сначала мы запрашиваем данные для нового дела от сервера, и только после их получения модифицируем <code>$todos</code>. Следующим шагом мы эту ситуацию постараемся исправить, но сначала обращу ваше внимание на другой интересный момент. Если мы вернемся чуть назад, к  <a href="https://dap.js.org/samples/tutorial/10-1.html">предыдущему варианту</a>, то заметим: хотя запрос там тоже присутствует, но новое дело добавляется в список моментально, не дожидаясь окончания запроса:

<source lang="javascript">
      // это предыдущая версия правила, :query тоже присутствует
      .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")
</source>

Это еще одна особенность отработки асинхронных конверторов в dap: если результат асинхронного конвертора не используется (а именно - ничему не присваивается), значит его завершения можно не ждать - и исполнение правила не блокируется. Это часто бывает полезно: возможно, вы заметили, что при удалении дел из списка - они исчезают с экрана мгновенно, не дожидаясь результата DELETE-запроса. Особенно это заметно, если быстро удалять несколько дел подряд и отслеживать запросы в панели Network.

Но, поскольку результат запроса POST мы используем - присваиваем его контексту <code>$</code> - то приходится ждать его завершения. Поэтому нужно найти другой способ модифицировать <code>$todos</code> до исполнения POST-запроса. Решение: все-таки сначала создать новое дело, добавить его в <code>$todos</code>, дать списку отрисоваться и только потом, после отрисовки, если у дела отсутствует <code>.url</code> (то есть это дело только что создано), выполнить POST-запрос, и его результат наложить на контекст.

Итак, сначала просто добавляем в список заготовку, содержащую только <code>.title</code>:

<source lang="javascript">
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$todos=($todos (#.value@title)@tgt):insert #.value=")
</source>

Правило генерации элемента <code>UL#todo-list > LI</code> уже содержит оператор <code>a!</code>, запускающий a-правило после первичной отрисовки элемента. Туда же можем добавить и запуск POST-запроса при отсутствии <code>.url</code>. Для инъекции дополнительных полей в контекст в dap имеется оператор <code>&</code>:

<source lang="javascript">
      ,'LI'.d("$completed=.completed $editing= $patch=; a!"
	  ...
      )
      .a("!? $completed $editing; ? .url:!; & (@method`POST todos@url headers $):query")
      .u("? $patch; (@method`PATCH .url:dehttp headers $patch@):query $patch=")
</source>

<a href="https://dap.js.org/samples/tutorial/10-3.html">Смотрим</a>. Другое дело! Даже при медленной сети список дел обновляется мгновенно, а уведомление сервера и подгрузка недостающих данных происходят в фоновом режиме, уже после отрисовки обновленного списка.


<h2>11. Галку всем!</h2>
В элементе <code>#header</code> присутствует кнопка массовой установки/сброса признака завершенности для всех дел в списке. Для массового присвоения значений полям элементов массива просто пишем еще один конвертор, <code>:assign</code>, и применяем его к <code>$todos</code> по клику на <code>INPUT#toggle-all</code>:

<source lang="javascript">
    ,'INPUT#toggle-all type=checkbox'
      .ui("$todos=($todos (#.checked@completed)@src):assign")
    ...
    assign: x => x.todos && x.todos.map(todo => Object.assign(todo,x.src))
</source>

В данном случае нас интересует только поле <code>.completed</code>, но легко видеть что таким конвертором можно массово менять значения любых полей элементов массива.
Ок, в массиве <code>$todos</code> галочки переключаются, теперь надо уведомить о сделанных изменениях сервер. В оригинальном примере это делается отсылкой PATCH-запросов для каждого дела - не слишком эффективная стратегия, но это уже не от нас зависит. Ок, для каждого дела отправляем PATCH-запрос:

<source lang="javascript">
      .ui("*@ $todos=($todos (#.checked@completed)@src):assign; (@method`PATCH .url headers (.completed)):query")
</source>

<a href="https://dap.js.org/samples/tutorial/11.html">Смотрим</a>: Клик по общей галке выравнивает все индивидуальные галки, и сервер уведомляется соответствующими PATCH-запросами. Норм.

<h2>12. Фильтрация дел по признаку завершенности</h2>
Кроме собственно списка дел, приложение должно еще иметь возможность фильтрации дел по признаку завершенности и показывать счетчики завершенных и незавершенных дел. Разумеется, для фильтрации мы будем банально использовать все тот же метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code>filter</code></a>, предоставляемый самим JS.

Но сначала нужно позаботиться о том, чтобы поле <code>.completed</code> каждого дела всегда соответствовало действительности, и обновлялось при клике индивидуальную галку дела вместе с переменной <code>$completed</code>. Раньше это нам не было важно, но теперь будет.
<source lang="javascript">
        ,'INPUT.toggle type=checkbox'
          .d("#.checked=.completed")
          .ui("$patch=(.completed=$completed=#.checked) $recount=()")
	      // поле .completed теперь тоже нужно поддерживать в актуальном состоянии
</source>
Важный момент здесь в том, что контекстом данных каждого дела является сам объект-дело, который лежит в массиве <code>$todos</code>. Не какая-то отдельная копия, или связанная конструкция, а сам объект собственной персоной. И все обращения к полям <code>.title</code>, <code>.completed</code>, .<code>url</code> - как на чтение, так и на запись - применяются непосредственно к этому объекту. Поэтому, чтобы фильтрация массива <code>$todos</code> работала корректно, нам нужно, чтобы завершенность дела отражалось не только галкой на экране, но и в поле <code>.completed</code> объекта-дела.

Чтобы показывать в списке только дела с нужным признаком завершенности <code>.completed</code>, будем просто фильтровать <code>$todos</code> в соответствии с выбранным фильтром. Выбранный фильтр - это, как вы уже догадались, еще одна переменная состояния нашего приложения, так ее и назовем: <code>$filter</code>. Для фильтрации <code>$todos</code> в соответствии с выбранным <code>$filter</code> пойдем по накатанной дорожке и просто добавим еще один конвертор, вида <i>{список,фильтр}=>отфильтрованный список</i>, а названия и фильтрующие функции будем брать из "ассоциативного массива" (то бишь, обычного JS-объекта) <code>todoFilters</code>:

<source lang="javascript">
const todoFilters={
  "All": null,
  "Active": todo => !todo.completed, 
  "Completed": todo => !!todo.completed
};

'#todoapp'.d("$todos= $filter=" // добавляем переменную $filter
    ...
    ,'UL#todo-list'.d("* ($todos $filter):filter"
    ...
    ,'UL#filters'.d("* filter" // константу filter с названиями фильтров берем из .DICT
      ,'LI'
	  .d("! .filter")
	  .ui("$filter=.") // такая запись эквивалентна "$filter=.filter"
    )
    ...
.DICT({
  ...
  filter: Object.keys(todoFilters) //["All","Active","Completed"]
})
.FUNC({
  convert:{
    ...    
    filter: x =>{
	const
	  a = x.todos,
	  f = x.filter && todoFilters[x.filter];
	return a&&f ? a.filter(f) : a;
    }
  }
})
</source>

<a href="https://dap.js.org/samples/tutorial/12-1.html">Проверяем</a>. Фильтры работают исправно. Есть нюанс в том, что названия фильтров выводятся слитно, т.к. здесь мы чуть отступили от DOM-структуры оригинала и выбились из CSS. Но к этому вернемся чуть позже.

<h2>13. Счетчики завершенных и активных дел.</h2>
Чтобы показать счетчики завершенных и активных дел, просто отфильтруем <code>$todos</code> соответствующими фильтрами и покажем длины получившихся массивов:

<source lang="javascript">
  ,'#footer'.d("$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter"
    ,'#todo-count'.d("! (active $active.length)format") // подставляем length в текстовый шаблон active
    ...
    ,'#clear-completed'.d("! (completed $completed.length)format")
  )
...
.DICT({
  ...
  active: "{length} items left",
  completed: "Clear completed items ({length})"
})
</source>

В <a href="https://dap.js.org/samples/tutorial/13-1.html">таком виде</a> счетчики показывают корректные значения при начальной загрузке, но не реагируют на последующие изменения завершенности дел (при кликах по галкам). Дело в том, что клики по галкам, меняя состояние каждого отдельного дела, не меняют состояние <code>$todos</code> - модификация элемента массива не является модификацией самого массива. Поэтому нам нужен дополнительный сигнал о необходимости переучета дел. Таким сигналом может стать дополнительная переменная состояния, которая модифицируется каждый раз, когда требуется переучет. Назовем ее <code>$recount</code>. Объявим в d-правиле общего предка, будем обновлять при кликах по галкам, а элемент <code>#footer</code> сделаем ее потребителем - для этого достаточно просто упомянуть эту переменную в его d-правиле.

<source lang="javascript">
'#todoapp'.d("$todos= $filter= $recount=" // объявляем $recount в общей области видимости
      ...
	  ,'INPUT.toggle type=checkbox'
          .d("#.checked=.completed")
          .ui("$patch=(.completed=$completed=#.checked) $recount=()") // присваиваем $recount новый пустой объект
	...
  ,'#footer'.d("$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter $recount" // упоминаем $recount
</source>

<a href="https://dap.js.org/samples/tutorial/13-2.html">Теперь</a> все работает как надо, счетчики обновляются корректно.

<h2>14. Удаление всех завершенных дел.</h2>
Пакетное удаление дел в TodoMVC реализуется так же некошерно, как и пакетная модификация - множественными запросами. Ну что же, вздохнем, разведем руками, и выполним по DELETE-запросу для каждого завершенного дела - а они у нас уже все есть в <code>$completed</code>. Соответственно, в <code>$todos</code> после удаления завершенных дел должно остаться то, что уже есть в <code>$active</code>:

<source lang="javascript">
    ,'#clear-completed'
      .d("! (completed $completed.length)format")
      .ui("$todos=$active; *@ $completed; (@method`DELETE .url:dehttp):query")
</source>

<a href="https://dap.js.org/samples/tutorial/14.html">Смотрим</a>: создаем несколько ненужных дел, помечаем их галками и удаляем. Вкладка Network покажет весь ужас подобного подхода к пакетным операциям.
 
<h2>15. Состояние в адресной строке</h2>
Вернемся к выбору фильтров. В оригинальном примере выбранный фильтр отражается в адресной строке после #. При изменении #-фрагмента в адресной строке вручную или при навигации - изменяется и выбранный фильтр. Это позволяет заходить на страницу приложения по URL с уже выбранным фильтром дел.

Писать в <code>location.hash</code> можно оператором <code>urlhash</code>, например, в a-правиле элемента <code>#todoapp</code> (или любого его потомка), которое будет исполняться при каждом обновлении <code>$filter</code>:

<source lang="javascript">
.a("urlhash $filter")
</source>

А инициализировать переменную <code>$filter</code> значением из адресной строки и потом обновлять по событию <i>hashchange</i> можно с помощью псевдо-конвертора <code>:urlhash</code>, который возвращает текущее состояние <code>location.hash</code> (без #):

<source lang="javascript">
.d("$todos= $filter=:urlhash $recount="
.e("hashchange","$filter=:urlhash")
</source>

Событие <i>hashchange</i> генерируется браузером при изменении #-фрагмента в адресной строке. Правда, слушать это событие почему-то могут только <code>window</code> и <code>document.body</code>. Чтобы отслеживать это событие из элемента <code>#todoapp</code>, придется добавить в его d-правило оператор <code>listen</code>, который подписывает элемент на ретрансляцию событий от объекта <code>window</code>:

<source lang="javascript">
'#todoapp'
.a("urlhash $filter")
.e("hashchange","$filter=:urlhash")
.d("$todos= $filter=:urlhash $recount=; listen @hashchange"
</source>

<a href="https://dap.js.org/samples/tutorial/15-1.html">Смотрим</a>: переключаем фильтры, отслеживаем изменения в адресной строке, заходим по ссылкам с <i>#Active</i>, <i>#All</i>, <i>#Completed</i>. Все работает.

Снова вернемся к оригиналу. Там, похоже, выбор фильтра так и реализован - переходами по ссылкам. Хоть это и не слишком практично, но для полноты эксперимента, так же сделаем и мы:

<source lang="javascript">
    ,'UL#filters'.d("* filter"
      ,'LI'.d(""
        ,'A'.d("!! (`# .filter)concat@href .filter@")
      )
    )
</source>

И чтобы выбранный фильтр выделялся, добавим оператор условной стилизации <code>!?</code>, который будет добавлять элементу CSS-класс selected, если значение в его поле <code>.filter</code> равно значению переменной <code>$filter</code>:

<source lang="javascript">
        ,'A'.d("!! (`# .filter)concat@href .filter@; !? (.filter $filter)eq@selected")
</source>

В <a href="https://dap.js.org/samples/tutorial/15-2.html">таком виде</a> функционал нашего dap-приложения уже полностью (насколько я могу судить) соответствует тому, что делает оригинал.

<h2>16. Пара завершающих штрихов</h2>
Мне не очень нравится, что в оригинале форма курсора не меняется над активными элементами, поэтому допишем в head нашего HTML-документа такой стиль:
<source lang="javascript">
    [ui=click]{cursor:pointer}
</source>
Так мы хотя бы будем видеть, где можно кликнуть.

Ах, да! Еще осталось написать большими буквами слово "todos". Но тут я, пожалуй, позволю себе наконец-то проявить немного фантазии и оригинальности и вместо просто "todos" напишу "dap todos"! 
<source lang="javascript">
    ,'H1'.d("","dap todos")
</source>
Вау. Теперь <a href="https://dap.js.org/samples/tutorial/16.html">наше приложение</a>  можно считать законченным, а туториал состоявшимся (если вы честно дочитали до этих строк).

<h2>В заключение</h2>
Возможно, при чтении у вас возникло впечатление, что dap-программа пишется методом проб и ошибок - вот эти все "посмотрим, что получилось", "вроде работает, но есть нюанс" и т.п. На самом деле это не так. Все эти нюансы вполне очевидны и предсказуемы при написании кода. Но я подумал, что будет полезно на примере этих нюансов показать, зачем в правилах присутствует то или иное решение и почему делается так, а не иначе.

Задавайте, как говорится, вопросы.