Пишем TodoMVC на dap. Часть 2.

Это продолжение туториала, в котором мы пишем TodoMVC-клиент с помощью минималистичного реактивного js-фреймворка dap.

Краткое содержание первой части: мы получили с сервера список дел в формате JSON, построили из него HTML-список, добавили возможность редактирования названия и признака завершенности для каждого дела, и реализовали уведомление сервера об этих реактированиях.

Осталось реализовать: удаление произвольных дел, добавление новых дел, фильтрацию дел по признаку завершенности и функцию удаления всех завершенных дел. Этим мы и займемся.

<cut/>

Полный код HTML-странички к концу первой части выглядит так:

[7-3]

Запустить его можно как локально, так и просто <a href="">здесь</a>. Будет много HTTP запросов к серверу, поэтому откройте, пожалуйста, инструменты разработчика (в Хроме это, как вы помните, Ctrl+Shift+I) - нам там будет интересна в первую очередь вкладка Network, и во вторую - Console.

Тут я должен сделать небольшое лирическое отступление. Если вы не читали первую часть туториала, я бы рекомендовал все же начать с нее. Если вы ее читали, но ничего не поняли, лучше прочитать еще раз. Как показывает опыт предыдущих двух моих статей (и самый первый комментарий к ч.1 этого туториала), синтаксис и принцип работы dap не всегда сразу понятны неподготовленному читателю. [TODO: попросить @token найти в интернетах картинку с взрывающимся мозгом школьника] Я предупредил.

Эта, вторая, часть туториала будет чуть сложней и интересней, чем первая. С вашего позволения, нумерацию глав продолжу с ч.1. Там мы досчитали до 7. Итак,

<h2>8. Делаем список дел переменной состояния</h2>

Для удаления "дела" из списка есть кнопка BUTTON.destroy. Удаление заключается в отправке серверу DELETE-запроса и собственно удалении с глаз долой соответствующего элемента LI со всем содержимым. С отправкой DELETE-запроса все понятно:

        ,'BUTTON.destroy'.ui("(@method`DELETE .url:dehttp):query")
        
А вот с удалением элемента возможны варианты. Можно было бы просто ввести еще одну переменную состояния, скажем, $deleted:

      ,'LI'.d("$completed=.completed $editing= $patch= $deleted=; a!" // Переменная $deleted как признак "удаленности"
        ...
        ,'BUTTON.destroy'.d("(@method`DELETE .url:dehttp):query $deleted=`yes") // включили $deleted - вроде как бы удалили
      )
      .a("!? $completed $editing $deleted") // а в CSS прописать .deleted{display:none}

И это бы как бы работало. Но было бы читерством. К тому же, дальше по курсу у нас будут фильтры и счетчики активных и завершенных "дел" (то, что находится в #footer). Поэтому, лучше будем сразу удалять объект из списка дел по-честному, "физически". То есть нам нужна возможность модифицировать сам массив, который мы изначально получаем от сервера. Этот массив тоже должен стать переменной состояния. Назовем ее $todos.

Областью определения переменной $todos нужно выбрать общего предка всех элементов, которые будут к этой переменной обращаться. А обращаться к ней будут и INPUT#new-todo из #header, и счетчики из #footer, и собственно UL#todo-list. Общий предок у них у всех - это корневой элемент шаблона, #todoapp. Следовательно, в его d-правиле и нужно определять переменную $todo, загружать в нее данные с сервера, и уже из нее строить список UL#todo-list:

<source>
'#todoapp'.d("$todos=todos:query" // Объявляем переменную $todos и загружаем в нее данные
      ...
    ,'UL#todo-list'.d("*@ $todos" // Строим список уже из $todos	
	  ...
</source>

Смотрим [8-1]. Здесь $todos <i>объявлена</i> и сразу же <i>инициализирована</i> в d-правиле элемента #todoapp. Вроде бы все работает, но появилась одна неприятная особенность. Если сервер долго отвечает на запрос (Chrome позволяет смоделировать такую ситуацию: на вкладке Network инструментов разработчика можно выбрать разные режимы имитации медленных сетей), то наша новая версия приложения до завершения запроса выглядит несколько печально - на экране нет ничего, кроме каких-то CSS-артефактов. Такая картина определенно не добавит оптимизма пользователю. Хотя предыдущая версия [7-3] этим не страдала - до получения данных на странице отсутствовал только сам список, но другие элементы появлялись сразу, не дожидаясь данных.

Дело вот в чем. Как вы, надеюсь, помните, конвертор :query - асинхронный. Асинхронность эта выражается в том, что до завершения запроса блокируется только исполнение текущего правила, то есть генерация элемента, которому, собственно, запрашиваемые данные и нужны (что логично). Генерация же других элементов не блокируется. Поэтому, когда к серверу обращался UL#todo-list - блокировался только он, но не #header и #footer. Теперь же завершения запроса ждет весь #todoapp.

<h2>9. Отложенная загрузка данных</h2>

Чтобы исправить ситуацию и избежать блокировки непричастных элементов, отложим первоначальную загрузку данных до момента, когда все уже отрисовалось. Для этого не будем сразу же загружать в переменную $todos данные, а просто проинициализируем ее "ничем"

<source>
'#todoapp'.d("$todos=" // Объявляем переменную $todos и инициализируем ее "ничем"
</source>

Так она не будет ничего блокировать и весь шаблон отработает - пусть пока и с пустым "списком дел". Зато теперь, с нескучным начальным экраном, можно спокойно <i>модифицировать</i> $todos, загрузив-таки в него список дел. Для этого добавим к #todoapp вот такого потомка:

<source>
  ,'loader'
    .u("$todos=todos:query") // модифицируем $todos, загружая в нее данные с сервера
    .d("u") // запустить реакцию (u-правило) сразу после генерации
</source>

Этот элемент имеет u-правило, которое выглядит точно так же, как и то блокирующее, от которого мы отказались, но здесь есть одно принципиальное отличие.
Напомню, что d-правило (от down) - это правило генерации элемента, которе исполняется построении шаблона сверху <i>вниз</i>, от родителя к потомкам; а u-правила (up) - это правила реакции, исполняемые в ответ на событие, всплывающее снизу <i>вверх</i>, от потомка к родителю.
Так вот, если переменной что-то (в т.ч. "ничто") присвается <b>в d-правиле</b>, это означает ее <i>объявление и инициализацию</i> в области видимости данного элемента и его потомков (в dap реализованы вложенные области видимости, как в JS). Присваивание же <b>в up-правилах</b> означает <i>модификацию</i> переменной, объявленной ранее в области видимости. Соответственно, u-правила не могут объявлять переменные, а d-правила не могут их модифицировать - что логично, учитывая их специфику. Объявление и инициализация переменных в d-правиле позволяет родителю передавать потомкам информацию, необходимую для построения, а модификация - позволяет передавать наверх обновления этой информации и соответствующую перестройку всех элементов, от нее зависящих.

Таким образом, элемент loader, будучи потомком #todoapp, в своем u-правиле <b>модифицирует</b> переменную $todos, загружая в нее данные с сервера, что вызывает автоматическую перегенерацию всех элементов-потребителей этой переменной - и только их, что важно. Потребители переменной - это элементы, d-правила которых содержат эту переменную в качестве rvalue, т.е. те, кто эту переменную (с учетом области видимости) читают.

Потребитель переменной $todos у нас сейчас один - тот самый UL#todo-list, который, соответственно, и будет перестроен после загрузки данных.

<source>
    ,'UL#todo-list'.d("*@ $todos" // вот он, потребитель переменной $todos	
</source>

Итак, теперь [9] у нас список дел является переменной состояния в #todoapp, при этом не блокируя первоначальной отрисовки шаблона.

<h2>10. Удаление и добавление дел</h2>

Теперь мы можем $todos модифицировать. Начнем с удаления элементов. У нас уже есть кнопка-крестик BUTTON.destroy, которая пока просто отсылает серверу запросы на удаление:

<source>
        ,'BUTTON.destroy'.ui("(@method`DELETE .url:dehttp):query")
</source>

Надо сделать так, чтобы соответствующий объект удалялся и из переменной $todos - а поскольку это тоже будет модификацией $todos, то UL#todo-list автоматически перестроится, уже без удаленного элемента.

Сам по себе dap не предоставляет никаких особых средств для манипуляций с данными. Сколь угодно сложные манипуляции можно прекрасно писать в функциях на JS, а dap-правила просто доставляют им данные и забирают результат. Напишем функцию удаления объекта из массива, не зная его номер. Например, такую:

<source>
const remove = (arr,tgt)=> arr.filter( obj => obj!=tgt );
</source>

Можно, наверно, написать и что-то более эффективное, но мы сейчас не об этом. Врядли нашему приложению придется работать со списками дел из миллионов пунктов.

Чтобы сделать эту функцию доступной из dap-правил, ее нужно добавить ее в секцию .FUNC, но перед этим решить, как мы хотим ее вызывать. Самый простой вариант в данном случае, пожалуй, вызвать ее из конвертора, принимающего объект { todos, tgt } и возвращающего отфильтрованный массив:

<source>
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''), // это здесь еще с первой части туториала
    remove: x => remove(x.todos,x.tgt) // удалить объект из массива
  }
})
</source>

но ничто не мешает определить эту функцию прямо внутри .FUNC (я уже говорил, что .FUNC - это на самом деле обычный JS-метод, а его аргумент - обычный JS-объект?) 

<source>
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''),
    remove: x => x.todos.filter( todo => todo!=x.tgt )
  }
})
</source>

Теперь мы можем обращаться к этому конвертору из dap-правил:

<source>
        ,'BUTTON.destroy'
	    .ui("$todos=($todos $@tgt):remove (@method`DELETE .url:dehttp):query")
</source>

Здесь мы сначала формируем объект, который в JS-нотации соответствует { todos, tgt:$ }, передаем его конвертору :remove, описанному в .FUNC, а полученный отфильтрованный результат возвращаем в $todos, таким образом модифицируя ее. Здесь $ - это контекст данных, элемент массива $todos, примененный к шаблону при генерации. После символа @ указывается псевдоним (alias) аргумента. Если @ отсутствует, то используется собственное имя аргумента. Похоже на недавнее нововведение ES6 - <a href="http://es6-features.org/#PropertyShorthand">property shorthand</a>.

Аналогичным образом делаем добавление нового дела в список, с помощью элемента INPUT#new-todo и POST-запроса:

<source>
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")

	...
	
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''),
    remove: x => x.todos.filter( todo => todo!=x.tgt ), // удалить объект из массива
    insert: x => x.todos.concat( [x.tgt] ) // добавить объект в массив
  }
})
</source>

Правило реакции эелемента INPUT#new-todo на стандартное UI-событие (для элементов INPUT стандартным dap считает событие change) включает: чтение пользовательского ввода из свойства value этого элемента INPUT, формирование локального контекста $ с этим значением в качестве поля title, отправку контекста $ серверу методом POST, модификацию массива $title добавлением контекста $ в качестве нового элемента и наконец, очистку свойства value элемента INPUT.

Здесь юный читатель может спросить: зачем при добавления элемента в массив использовать <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">concat()</a>, если это можно сделать с помощью обычного <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push">push()</a>? Опытный же читатель сразу поймет в чем дело, и напишет свой вариант ответа в комментариях.

Смотрим, что получилось [10-1] Дела добавляются и удаляются нормально, соответствующие запросы серверу отправляются исправно (вы же держите вкладку Network открытой все это время, верно?). Но что если мы захотим изменить название или статус свежедобавленного дела? Проблема в том, что для уведомления сервера об этих изменениях нам потребуется .url, который назначает этому делу сервер. Мы, когда это дело создавали, его .url не знали, соответственно, корректный PATCH-запрос на изменение сформировать не можем.
На самом деле, вся необходимая информация о деле содержится в ответе сервера на POST-запрос, и корректней было бы новый объект-дело создавать не просто из пользовательского ввода, а из ответа сервера, и в $todos добавлять уже этот объект - со всей предоставляемой сервером информацией, в том числе и полем .url:

<source>
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$todos=($todos (@method`POST todos@url headers (#.value@title)):query@tgt ):insert #.value=")
</source>

Смотрим [10-2] - окей, теперь все отрабатывается корректно. Уведомления серверу о редактировании свежесозданных дел уходят корректно.

Можно было бы на этом и остановиться... Но если приглядеться, то все же можно заметить небольшую задержку между вводом названия нового дела и моментом его появления в списке. Эту задержку очень хорошо заметно, если включить имитацию медленной сети. Как вы уже догадались, дело в запросе к серверу: сначала мы запрашиваем данные для нового дела от сервера, и только после их получения модифицируем $todos. Следующим шагом мы эту ситуацию попробуем исправить, но сначала обращу ваше внимание на еще один интересный момент.
