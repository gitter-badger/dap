Пишем TodoMVC на dap. Часть 2.

Это продолжение туториала, в котором мы пишем TodoMVC-клиент с помощью минималистичного реактивного js-фреймворка dap.

Краткое содержание первой части: мы получили с сервера список дел в формате JSON, построили из него HTML-список, добавили возможность редактирования названия и признака завершенности для каждого дела, и реализовали уведомление сервера об этих редактированиях.

Осталось реализовать: удаление произвольных дел, добавление новых дел, фильтрацию дел по признаку завершенности и функцию удаления всех завершенных дел. Этим мы и займемся.

<cut/>

Полный код HTML-странички к концу первой части выглядел так:

[7-3]

Запустить его <a href="">отсюда</a>. Будет много HTTP запросов к серверу, поэтому откройте, пожалуйста, инструменты разработчика (в Хроме это, как вы помните, Ctrl+Shift+I) - там будет интересна в первую очередь вкладка Network, и во вторую - Console. Также не забываем просматривать код каждой версии нашей странички - в Хроме это Ctrl+U.

Тут я должен сделать небольшое лирическое отступление. Если вы не читали первую часть туториала, я бы рекомендовал все же начать с нее. Если вы ее читали, но ничего не поняли - лучше прочитать еще раз. Как показывает опыт предыдущих двух моих статей (и самый первый комментарий к ч.1 этого туториала), синтаксис и принцип работы dap не всегда сразу понятны неподготовленному читателю. [TODO: попросить @token найти в интернетах картинку с взрывающимся мозгом школьника] Я предупредил.

Эта, вторая, часть туториала будет чуть сложней и интересней, чем первая. С вашего позволения, нумерацию глав продолжу с ч.1. Там мы досчитали до 7. Итак,

<h2>8. Делаем список дел переменной состояния</h2>

Для удаления дела из списка есть кнопка BUTTON.destroy. Удаление заключается в отправке серверу DELETE-запроса и собственно удалении с глаз долой соответствующего элемента LI со всем содержимым. С отправкой DELETE-запроса все понятно:

        ,'BUTTON.destroy'.ui("(@method`DELETE .url:dehttp):query")
        
А вот с удалением элемента возможны варианты. Можно было бы просто ввести еще одну переменную состояния, скажем, $deleted:

      ,'LI'.d("$completed=.completed $editing= $patch= $deleted=; a!" // Переменная $deleted как признак "удаленности"
        ...
        ,'BUTTON.destroy'.d("(@method`DELETE .url:dehttp):query $deleted=`yes") // включили $deleted - вроде как бы удалили
      )
      .a("!? $completed $editing $deleted") // а в CSS прописать .deleted{display:none}

И это бы как бы работало. Но было бы читерством. К тому же, дальше по курсу у нас будут фильтры и счетчики активных и завершенных "дел" (то, что находится в #footer). Поэтому, лучше будем сразу удалять объект из списка дел по-честному, "физически". То есть нам нужна возможность модифицировать сам массив, который мы изначально получаем от сервера. Этот массив тоже должен стать переменной состояния. Назовем ее $todos.

Областью определения переменной $todos нужно выбрать общего предка всех элементов, которые будут к этой переменной обращаться. А обращаться к ней будут и INPUT#new-todo из #header, и счетчики из #footer, и собственно UL#todo-list. Общий предок у них у всех - это корневой элемент шаблона, #todoapp. Следовательно, в его d-правиле и нужно определять переменную $todo, загружать в нее данные с сервера, и уже из нее строить список UL#todo-list:

<source>
'#todoapp'.d("$todos=todos:query" // Объявляем переменную $todos и загружаем в нее данные
      ...
    ,'UL#todo-list'.d("*@ $todos" // Строим список уже из $todos	
	  ...
</source>

Смотрим [8-1]. Здесь $todos <i>объявлена</i> и сразу же <i>инициализирована</i> в d-правиле элемента #todoapp. Вроде бы все работает, но появилась одна неприятная особенность. Если сервер долго отвечает на запрос (Chrome позволяет смоделировать такую ситуацию: на вкладке Network инструментов разработчика можно выбрать разные режимы имитации медленных сетей), то наша новая версия приложения до завершения запроса выглядит несколько печально - на экране нет ничего, кроме каких-то CSS-артефактов. Такая картина определенно не добавит оптимизма пользователю. Хотя предыдущая версия [7-3] этим не страдала - до получения данных на странице отсутствовал только сам список, но другие элементы появлялись сразу, не дожидаясь данных.

Дело вот в чем. Как вы, надеюсь, помните, конвертор :query - асинхронный. Асинхронность эта выражается в том, что до завершения запроса блокируется только исполнение текущего правила, то есть генерация элемента, которому, собственно, запрашиваемые данные и нужны (что логично). Генерация же других элементов не блокируется. Поэтому, когда к серверу обращался UL#todo-list - блокировался только он, но не #header и #footer. Теперь же завершения запроса ждет весь #todoapp.

<h2>9. Отложенная загрузка данных</h2>

Чтобы исправить ситуацию и избежать блокировки непричастных элементов, отложим первоначальную загрузку данных до момента, когда все уже отрисовалось. Для этого не будем сразу же загружать в переменную $todos данные, а просто проинициализируем ее "ничем"

<source>
'#todoapp'.d("$todos=" // Объявляем переменную $todos и инициализируем ее "ничем"
</source>

Так она не будет ничего блокировать и весь шаблон отработает - пусть пока и с пустым "списком дел". Зато теперь, с нескучным начальным экраном, можно спокойно <i>модифицировать</i> $todos, загрузив-таки в него список дел. Для этого добавим к #todoapp вот такого потомка:

<source>
  ,'loader'
    .u("$todos=todos:query") // модифицируем $todos, загружая в нее данные с сервера
    .d("u") // запустить реакцию (u-правило) сразу после генерации
</source>

Этот элемент имеет u-правило, которое выглядит точно так же, как и то блокирующее, от которого мы отказались, но здесь есть одно принципиальное отличие.
Напомню, что d-правило (от down) - это правило генерации элемента, которе исполняется построении шаблона сверху <i>вниз</i>, от родителя к потомкам; а u-правила (up) - это правила реакции, исполняемые в ответ на событие, всплывающее снизу <i>вверх</i>, от потомка к родителю.
Так вот, если переменной что-то (в т.ч. "ничто") присвается <b>в d-правиле</b>, это означает ее <i>объявление и инициализацию</i> в области видимости данного элемента и его потомков (в dap реализованы вложенные области видимости, как в JS). Присваивание же <b>в up-правилах</b> означает <i>модификацию</i> переменной, объявленной ранее в области видимости. Соответственно, u-правила не могут объявлять переменные, а d-правила не могут их модифицировать - что логично, учитывая их специфику. Объявление и инициализация переменных в d-правиле позволяет родителю передавать потомкам информацию, необходимую для построения, а модификация - позволяет передавать наверх обновления этой информации и соответствующую перестройку всех элементов, от нее зависящих.

Таким образом, элемент loader, будучи потомком #todoapp, в своем u-правиле <b>модифицирует</b> переменную $todos, загружая в нее данные с сервера, что вызывает автоматическую перегенерацию всех элементов-потребителей этой переменной - и только их, что важно. Потребители переменной - это элементы, d-правила которых содержат эту переменную в качестве rvalue, т.е. те, кто эту переменную (с учетом области видимости) читают.

Потребитель переменной $todos у нас сейчас один - тот самый UL#todo-list, который, соответственно, и будет перестроен после загрузки данных.

<source>
    ,'UL#todo-list'.d("*@ $todos" // вот он, потребитель переменной $todos	
</source>

Итак, теперь [9] у нас список дел является переменной состояния в #todoapp, при этом не блокируя первоначальной отрисовки шаблона.

<h2>10. Удаление и добавление дел</h2>

Теперь мы можем $todos модифицировать. Начнем с удаления элементов. У нас уже есть кнопка-крестик BUTTON.destroy, которая пока просто отсылает серверу запросы на удаление:

<source>
        ,'BUTTON.destroy'.ui("(@method`DELETE .url:dehttp):query")
</source>

Надо сделать так, чтобы соответствующий объект удалялся и из переменной $todos - а поскольку это тоже будет модификацией $todos, то UL#todo-list автоматически перестроится, уже без удаленного элемента.

Сам по себе dap не предоставляет никаких особых средств для манипуляций с данными. Сколь угодно сложные манипуляции можно прекрасно писать в функциях на JS, а dap-правила просто доставляют им данные и забирают результат. Напишем функцию удаления объекта из массива, не зная его номер. Например, такую:

<source>
const remove = (arr,tgt)=> arr.filter( obj => obj!=tgt );
</source>

Можно, наверно, написать и что-то более эффективное, но мы сейчас не об этом. Врядли нашему приложению придется работать со списками дел из миллионов пунктов.

Чтобы сделать эту функцию доступной из dap-правил, ее нужно добавить в секцию .FUNC, но перед этим решить, как мы хотим ее вызывать. Самый простой вариант в данном случае, пожалуй, вызвать ее из конвертора, принимающего объект { todos, tgt } и возвращающего отфильтрованный массив:

<source>
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''), // это здесь еще с первой части туториала
    remove: x => remove(x.todos,x.tgt) // удалить объект из массива
  }
})
</source>

но ничто не мешает определить эту функцию прямо внутри .FUNC (я уже говорил, что .FUNC - это на самом деле обычный JS-метод, а его аргумент - обычный JS-объект?) 

<source>
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''),
    remove: x => x.todos.filter( todo => todo!=x.tgt )
  }
})
</source>

Теперь мы можем обращаться к этому конвертору из dap-правил:

<source>
        ,'BUTTON.destroy'
	    .ui("$todos=($todos $@tgt):remove (@method`DELETE .url:dehttp):query")
</source>

Здесь мы сначала формируем объект, который в JS-нотации соответствует { todos, tgt:$ }, передаем его конвертору :remove, описанному в .FUNC, а полученный отфильтрованный результат возвращаем в $todos, таким образом модифицируя ее. Здесь $ - это контекст данных, элемент массива $todos, примененный к шаблону при генерации. После символа @ указывается псевдоним (alias) аргумента. Если @ отсутствует, то используется собственное имя аргумента. Похоже на недавнее нововведение ES6 - <a href="http://es6-features.org/#PropertyShorthand">property shorthand</a>.

Аналогичным образом делаем добавление нового дела в список, с помощью элемента INPUT#new-todo и POST-запроса:

<source>
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")

	...
	
.FUNC({
  convert:{
    dehttp: url => url.replace(/^https?\:/,''),
    remove: x => x.todos.filter( todo => todo!=x.tgt ), // удалить объект из массива
    insert: x => x.todos.concat( [x.tgt] ) // добавить объект в массив
  }
})
</source>

Правило реакции эелемента INPUT#new-todo на стандартное UI-событие (для элементов INPUT стандартным dap считает событие change) включает: чтение пользовательского ввода из свойства value этого элемента INPUT, формирование локального контекста $ с этим значением в качестве поля title, отправку контекста $ серверу методом POST, модификацию массива $title добавлением контекста $ в качестве нового элемента и наконец, очистку свойства value элемента INPUT.

Здесь юный читатель может спросить: зачем при добавления элемента в массив использовать <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">concat()</a>, если это можно сделать с помощью обычного <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push">push()</a>? Опытный же читатель сразу поймет в чем дело, и напишет свой вариант ответа в комментариях.

Смотрим, что получилось [10-1] Дела добавляются и удаляются нормально, соответствующие запросы серверу отправляются исправно (вы же держите вкладку Network открытой все это время, верно?). Но что если мы захотим изменить название или статус свежедобавленного дела? Проблема в том, что для уведомления сервера об этих изменениях нам потребуется .url, который назначает этому делу сервер. Мы, когда это дело создавали, его .url не знали, соответственно, корректный PATCH-запрос на изменение сформировать не можем.
На самом деле, вся необходимая информация о деле содержится в ответе сервера на POST-запрос, и корректней было бы новый объект-дело создавать не просто из пользовательского ввода, а из ответа сервера, и в $todos добавлять уже этот объект - со всей предоставляемой сервером информацией, в том числе и полем .url:

<source>
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$todos=($todos (@method`POST todos@url headers (#.value@title)):query@tgt ):insert #.value=")
</source>

Смотрим [10-2] - окей, теперь все отрабатывается корректно. Уведомления серверу о редактировании свежесозданных дел уходят корректно.

Можно было бы на этом и остановиться... Но если приглядеться, то все же можно заметить небольшую задержку между вводом названия нового дела и моментом его появления в списке. Эту задержку очень хорошо заметно, если включить имитацию медленной сети. Как вы уже догадались, дело в запросе к серверу: сначала мы запрашиваем данные для нового дела от сервера, и только после их получения модифицируем $todos. Следующим шагом мы эту ситуацию попробуем исправить, но сначала обращу ваше внимание на еще один интересный момент. Если мы вернемся чуть назад, к предыдущему варианту [10-1], то заметим, что хотя запрос там тоже присутствует, но новое дело добавляется в списиок моментально, не дожидаясь окончания запроса:

<source>
      // это предыдущая версия правила
      .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")
</source>

Это еще одна особенность отработки асинхронных конверторов в dap: если результат асинхронного конвертора не используется (а именно - ничему не присваивается), то исполнение правила не блокируется. Это часто бывает полезно: возможно, вы заметили, что при удалении дел из списка - они исчезают с экрана мгновенно, не дожидаясь результата DELETE-запроса. Особенно это заметно, если быстро удалять несколько дел подряд и отслеживать запросы в панели Network.

Но, поскольку результат запроса POST мы используем - присваеваем его контексту $ - то приходится ждать его завершения, поэтому нужно найти другой способ модифицировать $todos до исполнения POST-запроса. Решение - все-таки сначала создать новое дело, добавить его в $todos, дать списку отрисоваться и только потом, если у дела отсутствует .url (то есть это дело только что создано), выполнить POST-запрос, и его результат наложить на объект-дело.

Сначала просто добавляем в список заготовку, содержащую только .title:

<source>
    ,'INPUT#new-todo placeholder="What needs to be done?" autofocus'
      .ui("$todos=($todos (#.value@title)@tgt):insert #.value=")
</source>

Правило генерации элемента UL#todo-list > LI уже содержит оператор a!, запускающий a-правило после первичной отрисовки элемента. Туда же можем добавить и запуск POST-запроса при отсутствии .url. Для инъекции дополнительных полей в контекст в dap имеется оператор %

<source>
      ,'LI'.d("$completed=.completed $editing= $patch=; a!"
	  ...
      )
      .a("!? $completed $editing; ? .url:!; % (@method`POST todos@url headers):query")
      .u("? $patch; (@method`PATCH .url:dehttp headers $patch@):query $patch=")
</source>

Смотрим [10-3]. Другое дело! Даже при медленной сети список дел обновляется мгновенно, а уведомление сервера и подгрузка недостающих данных происходят в фоновом режиме, уже после отрисовки обновленного списка.

Еще один момент: нужно позаботиться о том, чтобы поле .completed каждого дела всегда соответствовало действительности и обновлялось при клике на галку вместе с переменной $completed.

        ,'INPUT.toggle type=checkbox'
          .d("#.checked=.completed")
          .ui("$patch=(.completed=$completed=#.checked) $recount=()")
	      // поле .completed теперь тоже нужно поддерживать в актуальном состоянии


11. Галку всем!
В элементе #header присутствует кнопка массовой установки/сброса признака завершенности для всех дел в списке. Для массового присвоения значений полям элементов массива просто пишем еще один конвертор, :assign, и применяем его к $todos по клику на INPUT#toggle-all:

<source>
    ,'INPUT#toggle-all type=checkbox'
      .ui("$todos=($todos (#.checked@completed)@src):assign")
    ...
    assign: x => x.todos && x.todos.map(todo => Object.assign(todo,x.src))
</source>

В данном случае нас интересует только поле .completed, но легко видеть что таким конвертором можно массово менять значения любых полей элементов массива.
Ок, в массиве $todos галочки переключаются, теперь надо уведомить о сделанных изменениях сервер. В оригинальном примере это делается отсылкой PATCH-запросов для каждого дела - не слишком эффективная стратегия, но это уже не от нас зависит. Ок, для каждого дела отправляем PATCH-запрос:

<source>
      .ui("*@ $todos=($todos (#.checked@completed)@src):assign; (@method`PATCH .url headers (.completed)):query")
</source>

Смотрим [11]: Клик по общей галке выравнивает все индивидуальные галки, и сервер уведомляется соответствующими PATCH-запросами. Норм.

12. Фильтрация дел по признаку завершенности
Кроме сообственно списка дел, приложение должно еще показывать счетчики завершенных и незавершенных дел, и иметь возможность показывать как все наличествующие дела, так и только завершенные и только незавершенные.

Разумеется, для фильтрации мы будем банально использовать все тот же метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a>, предоставляемый самим JS.

Чтобы показывать в списке только дела с нужным признаком завершенности, будем просто фильтровать $todos в соответствии с выбранным фильтром. Выбранный фильтр - это, как вы уже догадались, еще одна переменная состояния нашего приложения. Так ее и назовем: $filter. А для фильтрации $todos в соответствии с выбранным $filter пойдем по накатанной дорожке и просто добавим еще один конвертор, вида <i>{список,фильтр}=>отфильтрованный список</i>, а функцию фильтра будем брать из "ассоциативного массива" todoFilters, для простоты просто по его названию.

<source>

const todoFilters={
  All: null,
  Active: todo => !todo.completed, 
  Completed: todo => !!todo.completed
};

'#todoapp'.d("$todos= $recount= $filter=" //
    ...
    ,'UL#todo-list'.d("* ($todos $filter):filter"
    ...
    ,'UL#filters'.d("* filter"
      ,'LI'
	  .d("! .filter")
	  .ui("$filter=.") // такая запись эквивалентна "$filter=.filter"
    )
    ...
.DICT({
  ...
  filter: Object.keys(todoFilters) //["All","Active","Completed"]
})
.FUNC({
  convert:{
    ...    
    filter: x =>{
	const
	  a = x.todos,
	  f = x.filter && todoFilters[x.filter];
	return a&&f ? a.filter(f) : a;
    }
  }
})

</source>

13. Счетчики завершенных и активных дел.
Чтобы показать счетчики завершенных и активных дел, просто отфильтруем $todos соответствующими фильтрами и покажем длины получившихся массивов:

<source>
  ,'#footer'.d("$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter"
    ,'#todo-count'.d("! (active $active.length)here")
    ...
    ,'#clear-completed'.d("! (completed $completed.length)here")
  )
...
.DICT({
  todos  : "//todo-backend-express.herokuapp.com/",
  headers: {"Content-type":"application/json"},
  active: "{length} items left",
  completed: "Clear completed items ({length})"
})
</source>

В таком [13-1] виде счетчики показывают корректные значения при начальной загрузке, но не реагируют на последующие изменения завершенности дел (при кликах по галкам). Дело в том, что клики по галкам, меняя состояние каждого отдельного дела, не меняют состояние $todos - модификация элемента массива не является модификацией самого массива. Поэтому нам нужен дополнительный сигнал о необходимости переучета дел. Таким сигналом может стать дополнительная переменная состояния, которая модифицируется каждый раз, когда требуется переучет. Назовем ее $recount. Объявим в d-правиле общего предка, будем обновлять при каждом клике на галку, а элемент #footer сделаем ее потребителем - для этого достаточно просто упомянуть ее в d-правиле. Еще нужно позаботиться о том, чтобы поле .completed в контексте обновленного дела тоже соответствовало действительности.

<source>
'#todoapp'.d("$todos= $filter= $recount=" // объявляем $recount в общей области видимости
      ...
	  ,'INPUT.toggle type=checkbox'
          .d("#.checked=.completed")
          .ui("$patch=(.completed=$completed=#.checked) $recount=()") // присваиваем $recount новый пустой объект
	...
  ,'#footer'.d("$recount $active=$todos:filter.active $completed=$todos:filter.completed" // упоминаем $recount
</source>

Теперь [13-2] все работает как надо, счетчики обновляются корректно.
