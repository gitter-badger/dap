Пишем TodoMVC на dap

TodoMVC, если кто не знает, это такой стандартнй UI-хелловорлд, позволяющий сравнить решения одной и той же задачи - условного "Списка дел" - средствами разных фреймворков.
Искать и изучать формальное описание задачи я не стал, а решил просто среверсить один из примеров, благо задача простая и понятная. Бэкенд в рамках этой статьи нам не интересен, поэтому сами мы его писать не будем, а воспользуемся <a href="https://todo-backend-express.herokuapp.com/">одним из готовых</a> с сайта https://www.todobackend.com/, оттуда же возьмем и <a href="https://www.todobackend.com/client/index.html?https://todo-backend-express.herokuapp.com/">пример клиента</a> и стандартный <a href="https://www.todobackend.com/client/css/vendor/todomvc-common.css">CSS-файл</a>.

Для использования dap вам не нужно ничего скачивать и устанавливать. Никаких npm install и вот этого всего. Достаточно любого тесктового редактора для написания и браузера для отладки. Еще для отладки нужен веб-сервер - достаточно простейшего, типа <a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb">вот этого расширения для Chrome</a>.

Итак, с чистого листа.

1. Создаем .html файл

<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Todo -- dap sample</title>
	<link rel="stylesheet" href="https://www.todobackend.com/client/css/vendor/todomvc-common.css"/>
	<script src="https://dap.js.org/0.4.js"></script>
</head>

<body>
<script>
// здесь будет dap
</script>
</body>

</html>

Обычная html-заготовка, в которой подключаем CSS-файл, любезно предоставляемый сайтом https://www.todobackend.com/ и dap-движок, не менее любезно предоставляемый сайтом https://dap.js.org/


2. Копируем DOM-структуру.

Чтобы пользоваться стандартным CSS-файлом без переделок, будем придерживаться той же DOM-структуры, что и оригинальный пример. Открываем <a href="https://www.todobackend.com/client/index.html?https://todo-backend-express.herokuapp.com/">оригинал</a> в браузере Chrome, жмем Ctr+Shift+I, выбираем вкладку Elements и видим, что собственно приложение находится в элементе <section id="todo-app">

<img src=""/>

Последовательно раскрывая это поддерево, переписываем его структуру в наш .html файл. Сейчас мы просто срисовываем по-быстренькому, а не пишем код, поэтому просто пишем сигнатуры элементов в одинарных кавычках, а в скобочках их детей. Если детей нет - рисуем пустые скобочки. Следим за индентами и балансом скобок.
<script>
// здесь будет dap

'#todoapp'(
	'#header'(
		'H1'()
		'INPUT#new-todo placeholder="What needs to be done?" autofocus'()
	)
	'#main'(
		'#toggle-all type=checkbox'()
		'UL#todo-list'(
			'LI'(
				'INPUT.toggle type=checkbox'()
				'LABEL'()
				'BUTTON.destroy'()
			)
		)
	)
	'#footer'(
		'#todo-count'()
		'UL#filters'(
			'LI'()
		)
		'#clear-completed'()
	)
)
</script>

Oбратите внимание: повторяющиеся элементы (например, здесь это элементы LI) мы пишем в структуру по одному разу, даже если в оригинале их несколько; очевидно, что это массивы из одного и того же шаблона. 

Формат сигнатур, думаю, понятен любому, кто писал руками HTML и CSS, поэтому останавливаться на нем подробно пока не буду. Скажу лишь, что теги пишутся ЗАГЛАВНЫМИ буквами, а отсутствие тега равносильно наличию тега DIV. Обилие здесь #-элементов (имеющих id) обусловлено спецификой подключаемого CSS-файла, в котором используются в основном как раз id-селекторы.



3. Вспоминаем, что dap-структура - это Javascript

Для задания структуры dap использует метод .d, внедренный в String.prototype (я в курсе, что внедрять свои методы в стандартные объекты - это айяйяй, но... короче, проехали), который преобразует строку-сигнатру в dap-шаблон. Первым аргументом он принимает правило генерации (d-правило), и остальными аргументами - произвольное число чайлдов. Исходя из этого нового знания, дописываем наш код так, чтобы вместо каждой открывающей скобки у нас была последовательность <code>.d(""</code>, а перед каждой открывающей одинарной кавычкой, кроме самой первой, была запятая. Лайфхак: можно воспользоваться автозаменой.


// здесь будет dap

'#todoapp'.d(""
	,'#header'.d(""
		,'H1'.d("")
		,'INPUT#new-todo placeholder="What needs to be done?" autofocus'.d("")
	)
	,'#main'.d(""
		,'#toggle-all type=checkbox'.d("")
		,'UL#todo-list'.d(""
			,'LI'.d(""
				,'INPUT.toggle type=checkbox'.d("")
				,'LABEL'.d("")
				,'BUTTON.destroy'.d("")
			)
		)
	)
	,'#footer'.d(""
		,'#todo-count'.d("")
		,'UL#filters'.d(""
			,'LI'.d("")
		)
		,'#clear-completed'.d("")
	)
)
.RENDER()

Вуаля! Мы получили дерево вызовов метода .d, которое уже готово трансформироваться в dap-шаблон. Пустые строки "" - это зародыши будущих d-правил, а чайлды стали перечисленными через запятую аргументами. Формально, это уже валидная dap-программа, хоть пока и не совсем с тем выхлопом, который нам нужен. Но ее уже можно запустить!
Для этого после закрывающей корневой скобки дописываем метод <code>.RENDER()</code>. Этот метод, как понятно из его названия, рендерит полученный шаблон.

Итак, на данном этапе имеем .html-файл вот с таким содержанием:

<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Todo -- dap sample</title>
	<link rel="stylesheet" href="https://www.todobackend.com/client/css/vendor/todomvc-common.css"/>
	<script src="https://dap.js.org/0.4.js"></script>
</head>

<body>
<script>
'#todoapp'.d(""
	,'#header'.d(""
		,'H1'.d("")
		,'INPUT#new-todo placeholder="What needs to be done?" autofocus'.d("")
	)
	,'#main'.d(""
		,'#toggle-all type=checkbox'.d("")
		,'UL#todo-list'.d(""
			,'LI'.d(""
				,'INPUT.toggle type=checkbox'.d("")
				,'LABEL'.d("")
				,'BUTTON.destroy'.d("")
			)
		)
	)
	,'#footer'.d(""
		,'#todo-count'.d("")
		,'UL#filters'.d(""
			,'LI'.d("")
		)
		,'#clear-completed'.d("")
	)
)
.RENDER()
</script>
</body>

</html>


Можно открыть его в браузере, чтобы убедиться, что DOM-элементы генерятся, CSS-стили подключаются, осталось только наполнить этот шаблон данными.


4. Получаем данные

Идем на страничку-оригинал, открываем в инструментах вкладку Network, включам фильтр XHR, и смотрим, откуда она берет данные, и в каком виде.
Окей, понятненько. Список дел берется прямо из https://todo-backend-express.herokuapp.com/ в виде json-массива объектов. Замечательно.

Для получения данных в dap имеется встроенный конвертор :query который асинхронно "конвертирует" URL в данные, с него полученные. Сам URL мы не будем писать прямо в правиле, а обозначим его константой todos; тогда вся конструкция по добыче данных будет выглядеть так:

todos:query

а саму константу todos пропишем словаре - секции .DICT, которая идет перед секцией .RENDER:

'#todoapp'.d(""
	...
)
.DICT({
	todos	: "https://todo-backend-express.herokuapp.com/"
})
.RENDER()


Получив массив todos, строим из него список дел: для каждого дела берем название из поля .title и пишем в LABEL, признак завершенности - берем из поля .completed и пишем в свойство checked элемента INPUT. Делается это так (смотрим на UL#todo-list):


'#todoapp'.d(""
	,'#header'.d(""
		,'H1'.d("")
		,'INPUT#new-todo placeholder="What needs to be done?" autofocus'.d("")
	)
	,'#main'.d(""
		,'#toggle-all type=checkbox'.d("")
		,'UL#todo-list'.d("*@ todos:query" // Оператор * повторяет правило для всех элементов массива
			,'LI'.d(""
				,'INPUT.toggle type=checkbox'.d("#.checked=.completed") // # обозначает "этот элемент"
				,'LABEL'.d("! .title") // Оператор ! просто добавляет текст в элемент
				,'BUTTON.destroy'.d("")
			)
		)
	)
	,'#footer'.d(""
		,'#todo-count'.d("")
		,'UL#filters'.d(""
			,'LI'.d("")
		)
		,'#clear-completed'.d("")
	)
)
.DICT({
	todos	: "http://todo-backend-express.herokuapp.com/"
})
.RENDER()

Обновляем эту нашу страничку в браузере и... ничего не происходит. Проблема в том, что современные браузеры не разрешают кросс-доменные XHR-запросы из локальных документов.
Пришло время смотреть нашу страничку через http - с помощью любого локального вебсервера (либо отключить это ограничение браузера, что я не советую).

Итак, заходим на нашу страничку по http:// и видим, что данные приходят, список строится. Ура! Вы уже освоили операторы * и !, конвертор :query, константы и доступ к полям текущего элемента массива. Посмотрите еще раз на получающийся код. Он вам все еще кажется нечитаемым?


5. Добавляем состояние.

Возможно, вы уже попробовали понажимать на галочки в списке дел. Сами галочки меняют цвет, но, в отличие от оригинала, родительский элемент 'LI' не меняет свой стиль (заврешенное дело должно становиться серым и зачеркнутым). Дело в том, что пока никакого состояния эти элементы не имеют и, соответственно, не могут его менять.

Добавим элементу LI состояние завершенности. Для этого определим в его d-правиле переменную состояния $completed. Элементу INPUT, который может это состояние менять, назначим соответствующее правило реакции (ui-правило), которое будет устанавливать переменную $completed в соответствии с собственным признаком checked. В зависимости от состояния $completed элементу LI будем либо включать, либо выключать css-класс completed.

		,'UL#todo-list'.d("*@ todos:query"
			,'LI'.d("$completed=.completed" // Переменная состояния, инициализируем из одноименного поля .completed
				,'INPUT.toggle type=checkbox'
					.d("#.checked=.completed") // Начальное состояние галочки берем из данных
					.ui("$completed=#.checked") // при нажатии обновляем переменную состояния $completed
				,'LABEL'.d("! .title")
				,'BUTTON.destroy'.d("")
			).a("!? $completed") // включам или выключаем css-класс completed в зависимости от значения в $completed
		)




