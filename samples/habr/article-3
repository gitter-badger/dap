Dap: тестирование и отладка

В комментария к прошлым статьям почтенная публика активно интересовалась, поддается ли dap дебагу. Вопросы вызывало



1. Синтаксические ошибки.

В браузерном варианте dap-программа строится, понятное дело, средствами javascript и включает, как правило, два уровня:

верхний уровень - собственно dap-правила, декларативно определяющие взаимосвязи между элементами.
нижний уровень - функторы, выполняющие целевые операции с данными.

Структура dap-шаблона и его правила задаются структурой вызовов соответствующих методов: .d, .a, .ui и др. Соответственно, синтаксические ошибки этого слоя - запятые, кавычки, баланс скобок и прочие подобные мелочи, в которых можно налажать при написании сложной структуры - отрабатываются javascript-движком браузера. А функторы, которыми оперируют dap-правила, это и вовсе обычные javascript-функции с определенными контрактами. Для отладки этого добра к вашим услугам все Инструменты Разработчика любого современного браузера.



2. Ошибки dap-компиляции (лексические).

По умолчанию, dap-программа компилируется лениво: шаблоны и правила парсятся при первом фактическом обращении к ним. Это позволяет размазать миллисекунды компиляции на множество мелких отрезков, а так же не тратить ресурсы на компиляцию неиспользуемых фрагментов. Обратной стороной такой заботы о ресурсах и TTS является то, что и об ошибках в dap-правилах становится известно только тогда, когда дело реально доходит до фрагментов с этими ошибками. Поэтому при разработке и тестировании полезно иметь возможность скомпилировать весь проект сразу, чтобы сразу видеть все ошибки компиляции.

Для "жадной" ahead-of-time компиляции шаблона имеется метод .COMPILE(), компилирующий шаблон сразу на всю глубину. При обнаружении ошибки в правиле, содержащий его элемент помечается атрибутом dap-error с сообщением об ошибке, это же сообщение дублируется в консоль. Обнаружение ошибки в правиле останавливает только компиляцию этого правила и не влияет на компиляцию других, поэтому такие ошибки отыскиваются не по одной за раз, а вплоть до "сразу все".

Синтаксис dap-правил очень прост и прямолинеен. В нем нет ключевых слов и управляющих конструкций, кроме скобок. "Синтаксических" ошибок как таковых в dap-правилах не бывает. Ошибки в dap правилах могут быть лексическими - связаными либо с прямыми ошибками в идентификаторах (а в dap идентификаторами являются все лексемы, кроме скобок, разделителей и литералов), либо с неправильным употреблением специальных символов: скобок (группировка), точки (доступ к полям), префиксов #$:@` и разделителей , и ;

Простые ошибки и опечатки в лексемах-идентификаторах транслируются в обращения к неиницализированным переменным или к несуществующим функторам, что трактуется как ошибка компиляции. Обращения к неопределенным константам (.DICT) тоже дают предупреждения в консоль.

Употребление спецсимволов не по назначению в dap формально допустимо: заблудившийся спецсимвол не будет распознан как ошибка, а будет трактоваться как обычный символ в лексеме. Но получившаяся лексема, вероятней всего, окажется неразрешаемой, то есть синтаксически окажется обращением либо к неинициализированной переменной, либо к неопределенному функтору - то есть тоже будет успешно распознана как ошибка компиляции.

Например:

Поскольку элементы с ошибками в правилах помечаются атрибутом dap-error, их можно визуально выделять с помощью CSS-селектора [dap-error]



3. Ошибки времени исполнения (логические)

Логические ошибки в императивных программах удобно отлавливать с помощью брейкпоинтов - точек останова, в которых можно посмотреть текущее состояние переменных, и затем, пошагово отслеживая их приключения, выяснять причины несоответсвия реальности ожиданиям.
В отличие от исполнения, скажем, javascript-программы, исполнение dap-программы является не процессом, а состоянием. Точнее совокупностью состояний множества элементов, составляющих dap-документ. Поэтому традиционные брейкпоинты для отладки dap-программы не особо актуальны: состояние каждого элемента можно просто посмотреть в Инструментах Разработчика. Каждый DOM-элемент, сгенерированный dap-программой, имеет свойство $, содержащее его контекст данных data, и контекст состояния stata. Анализа этих контекстов обычно достаточно для понимания происходящего.




3.


Dap-program debugging

By default, a dap-progam compiles lazily: templates and rules are parsed only before being actualy evaluated for the first time. This allows to break the compilation time into tiny, millisecond-scale timespans and spread them over the application execution time. This also prevents from spending resources for compilation never-actually-needed fragments of dap-programs.
The other side of this laziness of compilation is that the possible errors in dap rules remain undetected until the rule is actually evaluated. That is, if an ui event reaction rule contains an error, it will only show up on that event acually taking place. Obviously, such a behavior is hardly suitable for reliable testing. While developing and testing a dap-program, we want all compilation errors highlighted as soon as possible. The .COMPILE() method performs greedy all-depth down compilation of all rules of the template and all its descendants, unleashing all possible errors. Elements with errors in their rules are marked with a dap-error attribute, containing relevant error messages. These error messages are also printed to console.

Dap rule syntax is very simple and straightforward. It has no keywords or control constructs. Most errors in dap rules are generally rendered as wrong identifiers (in dap, all lexems are identifiers - except brackets, delimiters and literals)
Types of dap-errors.
